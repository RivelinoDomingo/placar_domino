<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Placar do Domin√≥ v2.0 (Integrado)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#000000" />
    <link rel="icon" href="icons/icone192.png" />
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f0f2f5; }
        .font-condensed { font-family: 'Roboto Condensed', sans-serif; }
        .view { display: none; }
        .view.active { display: block; }

        /* Menu Dropdown */
        .dropdown-menu {
            transform-origin: top right;
            transition: all 0.2s ease-out;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }
        .dropdown-menu.open {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .achievement-icon { font-size: 1.5rem; filter: grayscale(80%); opacity: 0.4; transition: all 0.3s; }
        .achievement-icon.unlocked { filter: grayscale(0%); opacity: 1; }
        .player-name-clickable { cursor: pointer; transition: color 0.2s; }
        .player-name-clickable:hover { color: #2563eb; }

        /* Mesa Grid */
        .mesa-grid { display: grid; grid-template-columns: 1fr 2fr 1fr; grid-template-rows: 1fr 2fr 1fr; grid-template-areas: ". top ." "left middle right" ". bottom ."; aspect-ratio: 1.5 / 1; width: 100%; max-width: 800px; }
        .player-slot-top { grid-area: top; }
        .player-slot-left { grid-area: left; }
        .player-slot-right { grid-area: right; }
        .player-slot-bottom { grid-area: bottom; }

        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        .point-dot { width: 10px; height: 10px; border-radius: 50%; transition: all 0.3s ease; }
        .team-legend { transition: opacity 0.3s ease-in-out; }

        /* Accordion */
        #liveMatchFeed {
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        #liveMatchFeed.open {
            max-height: 500px;
            padding: 1rem;
        }
        #liveMatchChevron.open { transform: rotate(180deg); }

        .top-player { background-color: #f0fdf4; border-left: 4px solid #22c55e; }
        .bottom-player { background-color: #fef2f2; border-left: 4px solid #ef4444; }

        /* Hist√≥rico Tabs */
        .history-details-tab { cursor: pointer; padding: 0.75rem 1rem; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .history-details-tab.active { border-bottom-color: #3b82f6; color: #2563eb; font-weight: 600; }
        .point-circle { width: 28px; height: 28px; }

        body.modal-open { overflow: hidden; height: 100vh; }

        /* Modais */
        #modalContainer, #adminOverlay {
            position: fixed; inset: 0; z-index: 9999;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            overscroll-behavior: contain;
            align-items: center; justify-content: center;
            padding: 1rem;
        }
        #adminOverlay.flex { display: flex; } /* Helper para display flex no toggle */

        #modalContent, #adminActionsPanel {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            width: 100%; max-width: 400px;
            position: relative;
        }
    </style>
</head>
<body class="text-gray-800 relative min-h-screen">

<div class="fixed top-4 right-4 z-50">
    <button id="mainMenuBtn" class="bg-white p-3 rounded-full shadow-lg text-gray-700 hover:bg-gray-100 transition active:scale-95 focus:outline-none">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="12" cy="5" r="1"></circle>
            <circle cx="12" cy="19" r="1"></circle>
        </svg>
    </button>

    <div id="mainMenuDropdown" class="dropdown-menu absolute right-0 mt-2 w-56 bg-white rounded-xl shadow-xl border border-gray-100 overflow-hidden">
        <div class="py-1">
            <button id="menuItemNotifications" class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-gray-700 transition">
                <span class="text-xl">üîî</span>
                <span class="font-medium">Notifica√ß√µes</span>
            </button>
            <button id="menuItemHistory" class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-gray-700 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-600"><path d="M3 3v18h18"/><path d="M7 14l5-5 4 4 5-5"/></svg>
                <span class="font-medium">Hist√≥rico</span>
            </button>

            <button id="menuItemStartGame" class="hidden w-full text-left px-4 py-3 hover:bg-green-50 flex items-center gap-3 text-green-700 transition font-bold border-t border-gray-100">
                <span class="text-xl">üÄÑ</span>
                <span class="font-medium">Iniciar Partida</span>
            </button>

            <div class="h-px bg-gray-100 my-1"></div>

            <button id="menuItemAdmin" class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-3 text-gray-700 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>
                <span class="font-medium">Administrador</span>
            </button>
        </div>
    </div>
</div>

<div id="app-container" class="container mx-auto max-w-2xl p-4 sm:p-6 lg:p-8">
    <div id="view-scoreboard" class="view active fade-in">

        <div class="text-center mb-8 pt-4"> <h1 class="text-4xl font-bold font-condensed tracking-wider">PLACAR DO DOMIN√ì</h1>
        </div>

        <div class="flex justify-center mb-8 hidden" id="goToGameModeContainer">
            <button id="btnGoToGameMode" class="bg-blue-600 text-white font-bold py-4 px-8 rounded-lg shadow-lg hover:bg-blue-700 transition-all duration-300 transform hover:scale-105">
                <span class="mr-2">üÄÑ</span> Iniciar Modo Partida
            </button>
        </div>

        <div id="liveMatchContainer" class="mb-6 transition-all duration-500">
            <div class="bg-white rounded-xl shadow-sm overflow-hidden">
                <div id="liveMatchHeader" class="flex justify-between items-center p-4 bg-gray-200 text-gray-500 cursor-default transition">
                    <h2 class="text-lg font-bold tracking-wider">‚óã NENHUMA PARTIDA ATIVA</h2>
                    <span id="liveMatchChevron" class="transform transition-transform duration-300 hidden">‚ñº</span>
                </div>
                <div id="liveMatchFeed" class="overflow-hidden"></div>
            </div>
        </div>

        <div id="playersList" class="space-y-3">
            <div class="text-center text-gray-500 p-8">Carregando placar...</div>
        </div>

        <div class="mt-10">
            <h2 class="text-xl font-bold text-gray-700 mb-3">√öltimas Atividades</h2>
            <div id="activityFeed" class="space-y-2 bg-white p-4 rounded-xl shadow-sm">
                <p class="text-gray-500 text-center">Carregando atividades...</p>
            </div>
        </div>

    </div>
    <div id="messageBox" class="message-box"></div>

<div id="view-game-table" class="view fade-in">
            <div class="flex justify-between mb-6" bis_skin_checked="1">
                <div calss="items-start" bis_skin_checked="1">
                    <button" id="btnBackToScoreboard" bis_skin_checked="1" class="text-gray-500 hover:text-gray-800 transition">‚ÜêVoltar</button"></div>
                        <div class="flex items-center" bis_skin_checked="1">
                            <div class="text-center" bis_skin_checked="1"><h2 class="text-3xl font-bold font-condensed">MODO PARTIDA</h2><p id="gameStatusText" class="text-gray-500">Vez de teste1</p></div>
                            <div class="w-24 sm:w-56" bis_skin_checked="1"></div>
                    </div>
            </div>
            <div class="bg-green-800 border-8 border-yellow-800/50 rounded-2xl shadow-2xl p-4 sm:p-8 mesa-grid mx-auto">
                <div class="flex items-center justify-center player-slot-top"><div id="slot-1" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-left"><div id="slot-4" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-right"><div id="slot-2" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-bottom"><div id="slot-3" class="player-slot flex flex-col items-center"></div></div>
            </div>
            <div class="mt-8 text-center space-y-4">
                <button id="btnStartGame" class="bg-gray-400 text-white font-bold py-3 px-6 rounded-lg shadow-md cursor-not-allowed" disabled>Iniciar Jogo</button>
                <div id="activeGameButtons" class="hidden flex-wrap justify-center gap-4"><button id="btnLaunchScore" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Lan√ßar Ponto</button><button id="btnUndoRound" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Desfazer</button><button id="btnSwapPlayer" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Trocar Jogador</button><button id="btnEndGame" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Encerrar Partida</button></div>
            </div>
        </div>

    <div id="view-game-over" class="view fade-in text-center pt-8">
        <h2 class="text-2xl text-gray-600">Fim de Jogo</h2>
        <p id="gameOverWinnerText" class="text-5xl font-bold font-condensed my-4 text-blue-600"></p>
        <p id="gameOverScoreText" class="text-xl text-gray-500 mb-8"></p>
        <div class="flex justify-center gap-4 flex-wrap">
            <button id="btnShareWhatsapp" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-green-600 transition flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg> Compartilhar</button><button id="btnGameSummary" class="bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-gray-600 transition">Ver Resumo</button><button id="btnNewGame" class="bg-blue-600 text-white hidden font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-blue-700 transition">üÄÑ Nova Partida</button><button id="btnBackToScoreboard_GameOver" class="bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-gray-600 transition">‚Üê Voltar ao Placar</button>
        </div>
    </div>

    <div id="view-history" class="view fade-in">
        <div class="flex justify-between items-center mb-6 pt-4">
            <button id="btnBackToScoreboardFromHistory" class="text-gray-500 hover:text-gray-800 transition">‚Üê Voltar</button>
            <h1 class="text-2xl sm:text-3xl font-bold font-condensed text-center">HIST√ìRICO</h1>
            <div class="w-12 sm:w-20"></div>
        </div>
        <div id="history-content-container">
            <div id="history-list-view">
                <div id="history-match-list" class="space-y-3">
                    <p class="text-center text-gray-500 p-8">Buscando hist√≥rico...</p>
                </div>
            </div>
            <div id="history-details-view" class="hidden">
                <div class="bg-white rounded-xl shadow-md p-4 sm:p-6">
                    <div id="history-details-header" class="text-center mb-4"></div>
                    <div class="border-b border-gray-200 flex justify-center mb-4">
                        <button data-tab="stats" class="history-details-tab active">Estat√≠sticas Gerais</button>
                        <button data-tab="raios" class="history-details-tab">An√°lise por Raio</button>
                    </div>
                    <div id="history-details-content"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="adminOverlay" class="hidden">
    <div id="adminActionsPanel" class="p-6">
        <div class="flex justify-between items-center mb-4 border-b pb-2">
            <h3 class="font-bold text-lg text-gray-800">Painel do Admin</h3>
            <button id="btnCloseAdminPanel" class="text-gray-400 hover:text-gray-600 p-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>

        <div id="adminLoginView">
            <p class="text-sm text-gray-600 mb-2">Insira a senha para gerenciar.</p>
            <input type="password" id="adminKeyInput" placeholder="Senha de Admin" class="w-full border-gray-300 rounded-md shadow-sm p-2 mb-3 bg-gray-50 focus:ring-2 focus:ring-blue-500 outline-none">
            <button id="activateAdminBtn" class="w-full bg-blue-600 text-white font-semibold py-2 rounded-md hover:bg-blue-700 transition">Ativar</button>
        </div>

        <div id="adminControlsView" class="hidden space-y-3">
            <button id="addPlayerBtn_fab" class="w-full bg-green-500 text-white font-semibold py-2 rounded-md hover:bg-green-600 transition flex items-center justify-center gap-2">
                <span>‚ûï</span> Adicionar Jogador
            </button>
            <button id="resetScoresBtn_fab" class="w-full bg-red-600 text-white font-semibold py-2 rounded-md hover:bg-red-700 transition flex items-center justify-center gap-2">
                <span>‚ö†Ô∏è</span> Redefinir Placar
            </button>
            <div class="bg-green-50 text-green-700 p-2 rounded text-center text-sm font-semibold border border-green-200 mt-2">
                ‚úì Modo Admin Ativo
            </div>
        </div>
    </div>
</div>

<div id="modalContainer" class="fixed inset-0 bg-black/60 hidden items-center justify-center p-4 z-50"><div id="modalContent" class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md m-auto"></div></div>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, getDocs, orderBy, limit, serverTimestamp, writeBatch, increment, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-messaging.js";

const firebaseConfig = {
    apiKey: "AIzaSyBqpkxcl0GkBBHVO8Nxk7UpYd00H4Frklc",
    authDomain: "placar-domino.firebaseapp.com",
    projectId: "placar-domino",
    storageBucket: "placar-domino.firebasestorage.app",
    messagingSenderId: "187178310074",
    appId: "1:187178310074:web:5f56292dea8dc776532583",
    measurementId: "G-BL3W42DJ3M"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

const ADMIN_KEY = 'Domino25';
const POINTS_TO_COMPLETE_RAIO = 4;
const appIdentifier = firebaseConfig.appId;

// --- ESTRUTURA DAS S√âRIES ---
const SERIES_CONFIG = [
    { name: 'Amador'},
    { name: 'D'},
    { name: 'C'},
    { name: 'B'},
    { name: 'A'}
    // Voc√™ pode adicionar mais s√©ries aqui no futuro! Ex: { name: 'Lend√°rio', requiredRaios: 100 }
];


const achievements = {
    primeiro_rei: { icon: 'üëë', name: 'Primeiro Rei', description: 'Chegou ao topo da S√©rie A.' },
    imbativel: { icon: 'üî•', name: 'Imbat√≠vel', description: 'Venceu 3 raios seguidos.' },
    desbravador: { icon: 'üßó‚Äç‚ôÇÔ∏è', name: 'Desbravador', description: 'Primeiro a chegar a uma nova s√©rie.'},
    azarao: { icon: 'üöë', name: 'Azar√£o', description: 'Sofreu 3 lambretas seguidas.' },
    roubo: { icon: 'üëÆüèªüöî', name: 'Ladr√£o', description: 'Ladr√£o de raio' },
    tanque_de_guerra: { icon: 'üéñÔ∏è', name: 'Dono da Mesa', description: 'Pontuou mais que o vencedor da partida' },

};

let appState = { players: {}, finalGameData: {}, activityFeed: [], isAdminMode: false, userId: null, gameState: {}, unsubscribers: [], messageQueue: [], isMessageShowing: false, matchHistory: [], currentMatchDetails: null };

const playersCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/players`);
const activityFeedCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/events`);
const matchesCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/partidas`);

function getCurrentSeasonNumber() {
    const firstSeasonStart = new Date("2025-07-06T00:00:00Z"); // voc√™ pode mudar essa data
    const now = new Date();
    const daysSinceStart = Math.floor((now - firstSeasonStart) / (1000 * 60 * 60 * 24));
    return Math.floor(daysSinceStart / 30);
}
const currentSeason = `temporada_${getCurrentSeasonNumber()}`;

// --- UI Objects Map Reformulado ---
const ui = {
    views: document.querySelectorAll('.view'),
    messageBox: document.getElementById('messageBox'),

    // Novos elementos do Menu
    menu: {
        btn: document.getElementById('mainMenuBtn'),
        dropdown: document.getElementById('mainMenuDropdown'),
        notifications: document.getElementById('menuItemNotifications'),
        history: document.getElementById('menuItemHistory'),
        admin: document.getElementById('menuItemAdmin'),
        startGame: document.getElementById('menuItemStartGame')
    },

    // Admin agora √© um overlay
    adminPanel: {
        overlay: document.getElementById('adminOverlay'),
        closeBtn: document.getElementById('btnCloseAdminPanel'),
        loginView: document.getElementById('adminLoginView'),
        controlsView: document.getElementById('adminControlsView'),
        keyInput: document.getElementById('adminKeyInput'),
        activateBtn: document.getElementById('activateAdminBtn'),
        addPlayerBtn: document.getElementById('addPlayerBtn_fab'),
        resetBtn: document.getElementById('resetScoresBtn_fab')
    },

    playersListDiv: document.getElementById('playersList'),
    activityFeedDiv: document.getElementById('activityFeed'),
    liveMatchContainer: document.getElementById('liveMatchContainer'),
    liveMatchHeader: document.getElementById('liveMatchHeader'),
    liveMatchFeed: document.getElementById('liveMatchFeed'),
    liveMatchChevron: document.getElementById('liveMatchChevron'),
    history: {
        backButton: document.getElementById('btnBackToScoreboardFromHistory'),
        listView: document.getElementById('history-list-view'),
        detailsView: document.getElementById('history-details-view'),
        matchList: document.getElementById('history-match-list'),
        detailsHeader: document.getElementById('history-details-header'),
        detailsContent: document.getElementById('history-details-content'),
        tabs: document.querySelectorAll('.history-details-tab')
    },
    modal: { container: document.getElementById('modalContainer'), content: document.getElementById('modalContent')},
    gameMode: {
        goToBtn: document.getElementById('btnGoToGameMode'),
        backBtn: document.getElementById('btnBackToScoreboard'),
        // modeButtons: document.querySelectorAll('.gameModeBtn'),
        // raioCheckbox: document.getElementById('raioModeCheckbox'),
        startBtn: document.getElementById('btnStartGame'),
        activeButtons: document.getElementById('activeGameButtons'),
        launchScoreBtn: document.getElementById('btnLaunchScore'),
        undoBtn: document.getElementById('btnUndoRound'),
        swapPlayerBtn: document.getElementById('btnSwapPlayer'),
        endBtn: document.getElementById('btnEndGame'),
        newGameBtn: document.getElementById('btnNewGame'),
        shareBtn: document.getElementById('btnShareWhatsapp'),
        backToScoreboard_GameOverBtn: document.getElementById('btnBackToScoreboard_GameOver'),
        statusText: document.getElementById('gameStatusText'),
        gameOver: { winnerText: document.getElementById('gameOverWinnerText'), gameSummaryBtn: document.getElementById('btnGameSummary'), scoreText: document.getElementById('gameOverScoreText')}
    }
};
// --- L√≥gica do Menu Suspenso ---
ui.menu.btn.addEventListener('click', (e) => {
    e.stopPropagation();
    ui.menu.dropdown.classList.toggle('open');
});

document.addEventListener('click', (e) => {
    if (!ui.menu.dropdown.contains(e.target) && !ui.menu.btn.contains(e.target)) {
        ui.menu.dropdown.classList.remove('open');
    }
});

// 1. Notifica√ß√µes
ui.menu.notifications.addEventListener('click', async () => {
    // Passo 1: Fecha o menu visualmente para n√£o atrapalhar
    ui.menu.dropdown.classList.remove('open');

    // Passo 2: Executa a l√≥gica de registro do Service Worker
    if ('serviceWorker' in navigator && 'Notification' in window) {
        try {
            // Registra (ou recupera) o Service Worker no escopo correto
            const registration = await navigator.serviceWorker.register('/placar_domino/service-worker.js', {
                scope: '/placar_domino/'
            });

            // console.log('SW registrado:', registration.scope);

            // Agora chama a fun√ß√£o passando o registration, como era antes
            requestPermissionAndGetToken(registration);

        } catch (error) {
            console.error('Erro ao registrar Service Worker:', error);
            showMessage("Erro t√©cnico ao ativar notifica√ß√µes.", "error");
        }
    } else {
        console.warn("SW ou Notification API n√£o suportado");
        showMessage("Seu dispositivo n√£o suporta notifica√ß√µes.", "error");
    }
});

// 2. Hist√≥rico
ui.menu.history.addEventListener('click', () => {
    ui.menu.dropdown.classList.remove('open');
    switchView('view-history');
    // loadMatchHistory();
    fetchMatchHistory();

    ui.history.backButton.addEventListener('click', showScoreboardFromHistory);

    ui.history.matchList.addEventListener('click', (e) => {
        const matchCard = e.target.closest('[data-match-id]');
        if (matchCard) {
            showMatchDetails(matchCard.dataset.matchId);
        }
    });

    ui.history.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            setActiveHistoryTab(tab.dataset.tab);
            renderActiveHistoryTab();
        });
    });
});

// 3. Admin (Abre o Modal)
ui.menu.admin.addEventListener('click', () => {
    ui.menu.dropdown.classList.remove('open');
    ui.adminPanel.overlay.style.display = 'flex'; // Exibe o overlay
    setTimeout(() => ui.adminPanel.overlay.classList.remove('hidden'), 10);
});

// Fechar Admin
ui.adminPanel.closeBtn.addEventListener('click', () => {
    ui.adminPanel.overlay.style.display = 'none';
    ui.adminPanel.overlay.classList.add('hidden');
});

async function requestPermissionAndGetToken(swRegistration) {
    try {
        const permission = await Notification.requestPermission();
        if (permission !== "granted") {
            showMessage("Permiss√£o negada para notifica√ß√µes.", "info");
            return;
        }

        const messaging = getMessaging(app);

        // Chamada √∫nica e correta usando o par√¢metro swRegistration
        const currentToken = await getToken(messaging, {
            vapidKey: "BJdf45m2Tewt6PAawR7dbwpIwhP_iEsA4wirxSSOxd6dqhj1tGAJe_zTo3CznlFeTeHLdvOTYi6XjOdnbaYcqQw",
            serviceWorkerRegistration: swRegistration
        });

        if (currentToken) {
            // Salva no Firestore
            const tokensRef = collection(db, `artifacts/${appIdentifier}/public/data/subscriptions`);
            await setDoc(doc(tokensRef, currentToken), {
                timestamp: serverTimestamp(),
                browser: navigator.userAgent // √ötil para debug
            });

            console.log("Novo token gerado e salvo:", currentToken);
            showMessage("Notifica√ß√µes ativadas!", "success");
        } else {
            showMessage("Token n√£o p√¥de ser obtido.", "error");
        }
    } catch (error) {
        console.error("Erro ao obter permiss√£o ou token:", error);
        showMessage("Erro ao ativar notifica√ß√µes.", "error");
    }
}

async function handleStartGameClick() {
    if (!appState.isAdminMode) {
        showMessage("Apenas administradores podem iniciar uma partida.", "error");
        return;
    }

    const q = query(matchesCollectionRef(), where("status", "==", "active"));
    const activeGameSnapshot = await getDocs(q);

    if (activeGameSnapshot.empty) {
        // Se n√£o h√° jogo ativo, apenas limpa o estado e vai para a tela de prepara√ß√£o.
        resetGameState();
        switchView('view-game-table');
        updateGameModeUI();

    } else {
        // Se encontrou um jogo ativo, pergunta ao usu√°rio o que fazer.
        const gameDoc = activeGameSnapshot.docs[0];
        promptResumeGame(gameDoc.id, gameDoc.data());
    }
}

function setupActiveGameUI() {
    // Esconde os controles de pr√©-jogo
    ui.gameMode.startBtn.style.display = 'none';

    // Mostra os bot√µes de a√ß√£o da partida
    ui.gameMode.activeButtons.style.display = 'flex';
}

// FUN√á√ÉO 2: Chamada pelo bot√£o "Iniciar Jogo" na mesa, ap√≥s selecionar os jogadores.
// Ela efetivamente cria a partida no Firestore.
async function createGameInFirestore() {
    ui.gameMode.startBtn.disabled = true;
    try {
        // Limpeza de jogos "zumbis" continua aqui, como uma seguran√ßa extra.
        const q = query(matchesCollectionRef(), where("status", "==", "active"));
        const oldGames = await getDocs(q);
        if (!oldGames.empty) {
            const batch = writeBatch(db);
            oldGames.forEach(doc => batch.update(doc.ref, { status: 'aborted', endedAt: serverTimestamp() }));
            await batch.commit();
        }

        const { gameMode, selectedSlots } = appState.gameState;
        const playerIds = Object.values(selectedSlots).filter(Boolean);

        const requiredPlayers = 4;
        if(playerIds.length < requiredPlayers) {
            showMessage(`S√£o necess√°rios pelo menos ${requiredPlayers} jogadores para este modo.`, "error");
            ui.gameMode.startBtn.disabled = false;
            return;
        }

        let gameData = {
            gameMode, selectedSlots, playerIds, status: 'active',
            history: [], createdAt: serverTimestamp(),
            scores: playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {}),
            raios: playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {})
        };

        const gameDocRef = await addDoc(matchesCollectionRef(), gameData);
        appState.gameState.activeGameId = gameDocRef.id;

        const unsub = onSnapshot(gameDocRef, (doc) => {
            if (doc.exists()) renderActiveGame(doc.data());
        });
        appState.gameState.activeGameListener = unsub;
        appState.unsubscribers.push(unsub);

        setupActiveGameUI();
        showMessage("Nova partida iniciada!", "success");
    } catch (error) {
        console.error("Erro ao criar partida:", error);
        showMessage("N√£o foi poss√≠vel criar a partida.", "error");
        ui.gameMode.startBtn.disabled = false;
    }
}

// FUN√á√ÉO 3: Abre o modal de decis√£o (n√£o muda)
function promptResumeGame(gameId, gameData) {
    const playerNames = gameData.playerIds.map(id => appState.players[id]?.name || '?').join(', ');
    const modalHTML = `
        <h3 class="text-xl font-bold">Partida Ativa Encontrada</h3>
        <p class="my-4 text-gray-700">J√° existe uma partida em andamento com: <strong class="font-semibold">${playerNames}</strong>.</p>
        <p class="text-gray-700">O que voc√™ deseja fazer?</p>
        <div class="flex flex-col sm:flex-row justify-end gap-3 mt-6">
            <button id="btnDiscardAndNew" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition">Descartar e Iniciar Nova</button>
            <button id="btnResume" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Continuar Partida</button>
        </div>`;
    openModal(modalHTML);
    document.getElementById('btnResume').onclick = () => resumeGame(gameId, gameData);
    document.getElementById('btnDiscardAndNew').onclick = async () => {
        closeModal();
        await updateDoc(doc(matchesCollectionRef(), gameId), { status: 'aborted', endedAt: serverTimestamp() });
        resetGameState();
        switchView('view-game-table');
        showMessage("Partida anterior descartada.", "info");
    };
}

// FUN√á√ÉO 4: L√≥gica para continuar um jogo existente (n√£o muda)
function resumeGame(gameId, gameData) {
    closeModal();
    if (appState.gameState.activeGameListener) appState.gameState.activeGameListener();

    appState.gameState.activeGameId = gameId;
    appState.gameState.activeGame = gameData;
    appState.gameState.selectedSlots = gameData.selectedSlots;

    const gameDocRef = doc(matchesCollectionRef(), gameId);
    const unsub = onSnapshot(gameDocRef, (doc) => { if (doc.exists()) renderActiveGame(doc.data()); });
    appState.gameState.activeGameListener = unsub;
    appState.unsubscribers.push(unsub);

    switchView('view-game-table');
    renderAllSlots();
    setupActiveGameUI();
    showMessage("Partida recuperada com sucesso!", "success");
}

function generateScoreHTML(raiosDaPartida, pontosAtuais) {
    // Mostra os raios Ganhos APENAS nesta partida.
    // Gera o contador de raios
    const raioCounterHTML = raiosDaPartida > 1 ? `
        <span class="ml-1 text-sm font-bold text-yellow-700">(x${raiosDaPartida})</span>
    ` : '';

    const raiosHTML = raiosDaPartida > 0 ? `
        <div class="flex items-center justify-center text-2xl mt-2">
            <span>‚ö°Ô∏è</span>
            ${raioCounterHTML}
        </div>
    ` : '<div class="h-9"></div>'; // Espa√ßo reservado para manter a altura
    // const raiosHTML = Array.from({ length: raiosDaPartida }, () => `<span class="text-2xl" title="Raio da Partida">‚ö°Ô∏è</span>`).join('');

    let pontosHTML = Array.from({ length: pontosAtuais }, () => `<div class="point-dot bg-yellow-400" title="Ponto"></div>`).join('');

    let renderRaiosAndPoints = `
    <div class="flex flex-col items-center my-2">  <!-- flex-col para empilhar verticalmente -->
        ${raiosHTML}
        <div class="flex justify-center gap-1.5 mt-1"> <!-- Container para os pontos -->
            ${pontosHTML}
        </div>
    </div>
    `;

    return renderRaiosAndPoints;
}

function renderActiveGame(gameData) {
    // 1. Atualiza o estado local primeiro (crucial para tudo funcionar)
    appState.gameState.activeGame = gameData;

    // 2. Lida com os estados de fim de jogo
    if (gameData.status === 'finished') {
        processAndShowGameOver(gameData);
        return;
    }
    if (gameData.status === 'aborted') {
        resetGameState();
        switchView('view-scoreboard');
        return;
    }

    // 3. Atualiza o texto de status (Vez de...)
    const { turn } = gameData;
    const turnPlayerName = appState.players[turn]?.name || '';
    ui.gameMode.statusText.textContent = `Vez de ${turnPlayerName}`;

    // 4. Comanda uma renderiza√ß√£o completa da mesa.
    // Esta √∫nica linha garante que os nomes e placares sejam sempre atualizados.
    renderAllSlots();

    // 5. Atualiza o estado do bot√£o "Desfazer".
    ui.gameMode.undoBtn.disabled = gameData.history.length === 0;
}

async function promptLambretaManual(loserIds, winnerName) {
    // Esta fun√ß√£o usa uma 'Promise' para esperar a sele√ß√£o do usu√°rio
    return new Promise((resolve) => {
        // Monta o HTML do modal com checkboxes para cada perdedor
        let modalHTML = `
            <div class="flex justify-between items-start">
                <h3 class="text-xl font-bold">Registrar Lambretas</h3>
                <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <p class="text-sm text-gray-600 my-2">Rodada vencida por <span class="font-semibold">${winnerName}</span>. Selecione os perdedores que n√£o marcaram pontos:</p>
            <div class="space-y-2 mt-4">
        `;

        loserIds.forEach(id => {
            const player = appState.players[id];
            if (player) {
                modalHTML += `
                    <label for="lambreta-${id}" class="flex items-center p-3 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100 transition-all duration-200 border-2 border-transparent has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                        <input type="checkbox" id="lambreta-${id}" value="${id}" class="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span class="ml-3 font-medium">${player.name}</span>
                    </label>
                `;
            }
        });

        modalHTML += `</div><button id="confirmLambretas" class="mt-6 w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition">Confirmar Lambretas</button>`;

        openModal(modalHTML);

        // Fun√ß√£o para resolver e fechar
        const resolverSelecao = () => {
            const playersComLambreta = [];
            loserIds.forEach(id => {
                const checkbox = document.getElementById(`lambreta-${id}`);
                if (checkbox && checkbox.checked) {
                    playersComLambreta.push(id);
                }
            });
            closeModal();
            resolve(playersComLambreta); // Retorna a lista de IDs selecionados
        };

        // Adiciona os listeners para os bot√µes do modal
        document.getElementById('confirmLambretas').onclick = resolverSelecao;

        // Se o usu√°rio fechar no 'X', retorna uma lista vazia
        const closeBtn = document.getElementById('modal-close-btn');
        if(closeBtn) {
            closeBtn.onclick = () => {
                closeModal();
                resolve([]);
            };
        }
    });
}

async function launchScore() {
    if (!appState.gameState.activeGame) {
        showMessage("Aguarde, o jogo est√° sincronizando...", "error");
        return;
    }

    const { playerIds } = appState.gameState.activeGame;
    const WINNING_SCORE = 4;

    // 1. Cria√ß√£o do modal de sele√ß√£o do vencedor (Apenas Individual)
    let modalHTML = `<h3 class="text-2xl font-bold mb-4">Quem venceu a rodada?</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;

    const players = playerIds.map(id => appState.players[id]);
    modalHTML += playerIds.map(id => {
        const p = appState.players[id];
        return p ? `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition winner-select-btn" data-player-id="${id}">${p.name}</button>` : '';
    }).join('');

    modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;
    openModal(modalHTML);

    // 2. L√≥gica de sele√ß√£o do vencedor
    ui.modal.content.onclick = async (e) => {
        const target = e.target.closest('.winner-select-btn');
        if (!target) return;

        const winnerIdFromButton = target.dataset.playerId;
        const winnerNameFromButton = target.innerText;

        // console.log("CLIQUE DETECTADO:");
        // console.log("Nome no Bot√£o:", winnerNameFromButton);
        // console.log("ID no dataset:", winnerIdFromButton);
        // console.log("Nome esperado no Cache:", appState.players[winnerIdFromButton]?.name);

        closeModal();
        const batch = writeBatch(db);
        const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
        const currentGame = appState.gameState.activeGame;

        // winnerId capturado diretamente do bot√£o clicado
        const winnerId = target.dataset.playerId;
        const winnerPlayerDocRef = doc(playersCollectionRef(), winnerId);
        const newScore = (currentGame.scores[winnerId] || 0) + 1;

        const playerUpdates = {};
        const unlockedAchievements = {};
        let matchUpdates = {};
        let completedRaio = false;
        let lambretaLosersThisRound = [];
        let matchPointsThisRound = [];
        let stateScore = {};
        let ladraoDeRaio = { vitma: [], ladrao: [] };
        const loserIds = currentGame.playerIds.filter(id => id !== winnerId);

        // Atualiza√ß√£o de pontos na temporada
        playerUpdates[`${currentSeason}.pontosNaTemporada`] = increment(1);
        playerUpdates.pontos = increment(1);

        // L√≥gica de ladr√£o de raio (quando algu√©m est√° com 3 e o outro pontua)
        if (newScore >= 3) {
            let ladraoIsTrue = false;
            for (const jogador of loserIds) {
                if (currentGame.scores[jogador] === 0) {
                    ladraoDeRaio.ladrao.push(jogador);
                    if (!ladraoIsTrue) {
                        ladraoDeRaio.vitma.push(winnerId);
                        ladraoIsTrue = true;
                    }
                }
            }
        }

        if (newScore === 3) {
            playerUpdates[`${currentSeason}.matchPointsNaTemporada`] = increment(1);
            matchPointsThisRound.push(winnerId);
        }

        const jogadorRaiosLambretas = {};

        if (newScore >= WINNING_SCORE) {
            completedRaio = true;
            playerUpdates.raios = increment(1);
            playerUpdates.partidasJogadas = increment(1);
            playerUpdates[`${currentSeason}.raiosNaTemporada`] = increment(1);
            playerUpdates[`${currentSeason}.partidasNaTemporada`] = increment(1);

            // Atualiza partidas jogadas dos perdedores
            for (const loserId of loserIds) {
                batch.update(doc(playersCollectionRef(), loserId), {
                    [`${currentSeason}.partidasNaTemporada`]: increment(1),
                    partidasJogadas: increment(1)
                });
            }

            // L√≥gica de lambretas
            stateScore = { ...currentGame.scores, [winnerId]: newScore };

            for (const loserId of loserIds) {
                if ((stateScore[loserId] || 0) === 0) {
                    batch.update(doc(playersCollectionRef(), loserId), {
                        lambreta: increment(1),
                        [`${currentSeason}.lambretasNaTemporada`]: increment(1)
                    });
                    lambretaLosersThisRound.push(loserId);
                }
            }

            // L√≥gica de conquista Roubo de Raio
            const ultimoRaioIndex = currentGame.history.findLastIndex(r => r.completedRaio);
            const rodadasRelevantes = ultimoRaioIndex !== -1 ? currentGame.history.slice(ultimoRaioIndex + 1) : currentGame.history.slice();

            const vitimas = [];
            const ladroes = [];

            rodadasRelevantes.forEach(round => {
                if (round.ladraoDeRaio?.vitma?.length) {
                    vitimas.push(...round.ladraoDeRaio.vitma);
                    ladroes.push(...round.ladraoDeRaio.ladrao);
                }
            });

            const vitimasUnicas = [...new Set(vitimas)];
            const ladroesUnicos = [...new Set(ladroes)];

            if (ladroesUnicos.includes(winnerId)) {
                const vitimaId = vitimasUnicas.find(vId =>
                    rodadasRelevantes.some(r =>
                        r.ladraoDeRaio?.ladrao?.includes(winnerId) &&
                        r.ladraoDeRaio.vitma?.includes(vId)
                    )
                );

                if (vitimaId) {
                    showMessage(`${appState.players[winnerId]?.name} ROUBOU o raio de ${appState.players[vitimaId]?.name}! üïµÔ∏è‚Äç‚ôÇÔ∏è‚ö°`, 'warning');
                    await concederConquista(winnerId, 'roubo', `üöîüëÆüèªChama a policia que ${appState.players[winnerId]?.name} acabou de roubar o raio de ${appState.players[vitimaId]?.name}`);
                    if (!unlockedAchievements[winnerId]) unlockedAchievements[winnerId] = [];
                    unlockedAchievements[winnerId].push('roubo');
                }
            }

            // Feedback visual do raio
            showMessage(`${appState.players[winnerId].name} ganhou um Raio! ‚ö°Ô∏è`, 'success');

            // Backup para desfazer a√ß√£o se necess√°rio
            jogadorRaiosLambretas[winnerId] = {
                raiosNaTemporada: appState.players[winnerId][currentSeason]?.raiosNaTemporada || 0,
                lambretasNaTemporada: appState.players[winnerId][currentSeason]?.lambretasNaTemporada || 0,
                series: appState.players[winnerId].series || 0
            };

            for (const loserId of lambretaLosersThisRound) {
                showMessage(`${appState.players[loserId].name} tomou uma lambreta! üöë`, 'info');
                jogadorRaiosLambretas[loserId] = {
                    raiosNaTemporada: appState.players[loserId][currentSeason]?.raiosNaTemporada || 0,
                    lambretasNaTemporada: appState.players[loserId][currentSeason]?.lambretasNaTemporada || 0,
                    series: appState.players[loserId].series || 0
                };
            }

            // L√≥gica Conquista Imbat√≠vel (3 raios seguidos)
            const historicoDeRaios = currentGame.history.filter(r => r.completedRaio);
            if (historicoDeRaios.length >= 3) { // 2 anteriores + o atual = 3
                let vitoriasConsecutivas = 0;
                for (let i = historicoDeRaios.length - 1; i >= 0; i--) {
                    if (historicoDeRaios[i].winnerId === winnerId) vitoriasConsecutivas++;
                    else break;
                }
                if (vitoriasConsecutivas > 0 && vitoriasConsecutivas % 3 === 0) {
                    await concederConquista(winnerId, 'imbativel', `alcan√ßou uma sequ√™ncia de ${vitoriasConsecutivas} raios! üî•üöÄüöÄ`);
                    if (!unlockedAchievements[winnerId]) unlockedAchievements[winnerId] = [];
                    unlockedAchievements[winnerId].push('imbativel');
                }
            }

            // L√≥gica Conquista Azar√£o (3 lambretas seguidas)
            for (const jogadorId of playerIds) {
                let derrotasConsecutivas = (lambretaLosersThisRound.includes(jogadorId)) ? 1 : 0;
                if (derrotasConsecutivas === 0) continue;

                for (let i = historicoDeRaios.length - 1; i >= 0; i--) {
                    const round = historicoDeRaios[i];
                    if (round.lambretaPlayerIds?.includes(jogadorId)) {
                        derrotasConsecutivas++;
                    } else {
                        break;
                    }
                }
                if (derrotasConsecutivas > 0 && derrotasConsecutivas % 3 === 0) {
                    await concederConquista(jogadorId, 'azarao', `sofreu uma sequ√™ncia de ${derrotasConsecutivas} lambretas! üöëü§ïü§ï`);
                    if (!unlockedAchievements[jogadorId]) unlockedAchievements[jogadorId] = [];
                    unlockedAchievements[jogadorId].push('azarao');
                }
            }
        }

        // Constru√ß√£o do roundEvent
        matchUpdates.scores = { ...currentGame.scores, [winnerId]: newScore };
        matchUpdates.raios = currentGame.raios;
        matchUpdates.turn = winnerId;

        batch.update(winnerPlayerDocRef, playerUpdates);

        const roundEvent = {
            roundNumber: currentGame.history.length + 1,
            winnerId: winnerId,
            completedRaio: completedRaio,
            unlockedAchievements: unlockedAchievements,
            preUpdateStats: jogadorRaiosLambretas,
            timestamp: new Date()
        };

        if (lambretaLosersThisRound.length > 0) roundEvent.lambretaPlayerIds = lambretaLosersThisRound;
        if (matchPointsThisRound.length > 0) roundEvent.matchPointPlayerIds = matchPointsThisRound;

        if (completedRaio) {
            roundEvent.stateScore = {
                scores: currentGame.playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {}),
                raios: {
                    ...currentGame.raios,
                    [winnerId]: (currentGame.raios[winnerId] || 0) + 1
                }
            };
        } else {
            roundEvent.stateScore = {
                scores: matchUpdates.scores,
                raios: matchUpdates.raios
            };
        }

        if (ladraoDeRaio.vitma.length > 0) {
            roundEvent.ladraoDeRaio = ladraoDeRaio;
        }

        const newHistory = [...currentGame.history, roundEvent];

        // 1. Executa as atualiza√ß√µes das estat√≠sticas dos jogadores
        await batch.commit();

        if (completedRaio) {
            await atualizarAproveitamentoTemporada(winnerId);
            for (const loserId of loserIds) {
                await atualizarAproveitamentoTemporada(loserId);
            }
        }

        // 2. Atualiza o objeto da partida no banco
        matchUpdates.raios = roundEvent.stateScore.raios;
        matchUpdates.scores = roundEvent.stateScore.scores;
        matchUpdates.turn = winnerId;

        await updateDoc(gameDocRef, { ...matchUpdates, history: newHistory });
    };
}

async function undoRound() {
    const currentGame = appState.gameState.activeGame;
    if (!currentGame || currentGame.history.length === 0) return;

    const batch = writeBatch(db);
    const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
    const lastRound = currentGame.history[currentGame.history.length - 1];

    for (const playerId in lastRound.preUpdateStats){
        batch.update(doc(playersCollectionRef(), playerId), {
            [`${currentSeason}.raiosNaTemporada`]: lastRound.preUpdateStats[playerId].raiosNaTemporada,
            [`${currentSeason}.lambretasNaTemporada`]: lastRound.preUpdateStats[playerId].lambretasNaTemporada,
            series: lastRound.preUpdateStats[playerId].series
        });
    }

    // 1. Reverte estat√≠sticas b√°sicas
    batch.update(doc(playersCollectionRef(), lastRound.winnerId), {
        pontos: increment(-1),
        [`${currentSeason}.pontosNaTemporada`]: increment(-1)
    });
    // Reverte MatchPoints
    if (lastRound.matchPointPlayerIds?.length > 0){
        lastRound.matchPointPlayerIds.forEach(id => {
            batch.update(doc(playersCollectionRef(), id), {
                [`${currentSeason}.matchPointsNaTemporada`]: increment(-1),
            });
        });
    }

    if (lastRound.completedRaio) {
        batch.update(doc(playersCollectionRef(), lastRound.winnerId), {
            raios: increment(-1),
            partidasJogadas: increment(-1),
            [`${currentSeason}.partidasNaTemporada`]: increment(-1)
        });

        // Reverte partidas jogadas dos outros jogadores
        currentGame.playerIds.filter(id => id !== lastRound.winnerId).forEach(id => {
            batch.update(doc(playersCollectionRef(), id), {
                partidasJogadas: increment(-1),
                [`${currentSeason}.partidasNaTemporada`]: increment(-1)
            });
        });

        // Reverte lambretas
        if (lastRound.lambretaPlayerIds?.length > 0) {
            lastRound.lambretaPlayerIds.forEach(id => {
                batch.update(doc(playersCollectionRef(), id), {
                    lambreta: increment(-1),
                });
            });
        }
    }

    // 2. Reverte conquistas
    if (lastRound.unlockedAchievements) {
        for (const [playerId, achievements] of Object.entries(lastRound.unlockedAchievements)) {
            const playerRef = doc(playersCollectionRef(), playerId);
            achievements.forEach(ach => {
                batch.update(playerRef, {
                    [`conquistas.${ach}`]: increment(-1),
                    [`${currentSeason}.conquistasNaTemporada.${ach}`]: increment(-1)
                });

            });
        }
    }

    // 4. Restaura estado anterior do jogo
    const previousState = currentGame.history.length > 1 ?
        currentGame.history[currentGame.history.length - 2].stateScore : {
            scores: Object.fromEntries(currentGame.playerIds.map(id => [id, 0])),
            raios: Object.fromEntries(currentGame.playerIds.map(id => [id, 0]))
        };

    await batch.commit();

    // 5. Atualiza o documento do jogo
    await updateDoc(gameDocRef, {
        scores: previousState.scores,
        raios: previousState.raios,
        turn: lastRound.winnerId,
        history: currentGame.history.slice(0, -1)
    });

    showMessage("Rodada desfeita com todas as consequ√™ncias revertidas", "success");
}

function iniciarTrocaDeJogador() {
    if (!appState.isAdminMode || !appState.gameState.activeGame) return;

    const currentGame = appState.gameState.activeGame;
    const currentPlayers = currentGame.playerIds.map(id => appState.players[id]);

    let modalHTML = `<h3 class="text-2xl font-bold mb-4">Quem ser√° substitu√≠do?</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;
    currentPlayers.forEach(p => {
        if (p) {
            modalHTML += `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition" data-player-id-out="${p.id}">${p.name}</button>`;
        }
    });
    modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;
    openModal(modalHTML);

    ui.modal.content.onclick = (e) => {
        const playerOutBtn = e.target.closest('[data-player-id-out]');
        if (playerOutBtn) {
            const playerOutId = playerOutBtn.dataset.playerIdOut;
            // N√£o passa mais o 'currentGame'
            promptNovoJogadorParaTroca(playerOutId);
        }
    };
}

function promptNovoJogadorParaTroca(playerOutId) {
    const availablePlayers = Object.values(appState.players).filter(p => !appState.gameState.activeGame.playerIds.includes(p.id));

    if (availablePlayers.length === 0) {
        showMessage("N√£o h√° jogadores dispon√≠veis para a troca.", "error");
        return;
    }

    let modalHTML = `<h3 class="text-2xl font-bold mb-4">Selecione o Substituto</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;
    availablePlayers.forEach(p => {
        modalHTML += `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition" data-player-id-in="${p.id}">${p.name}</button>`;
    });
    modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;

    openModal(modalHTML);

    ui.modal.content.onclick = async (e) => {
        const playerInBtn = e.target.closest('[data-player-id-in]');
        if (playerInBtn) {
            const playerInId = playerInBtn.dataset.playerIdIn;
            // N√£o passa mais o 'currentGame'
            await executarTrocaNoBD(playerOutId, playerInId);
        }
    };
}

async function executarTrocaNoBD(oldPlayerId, newPlayerId) {
    closeModal();
    showMessage("Processando troca...", "info");

    const gameId = appState.gameState.activeGameId;
    if (!gameId) return;

    const gameDocRef = doc(matchesCollectionRef(), gameId);

    try {
        const gameDocSnapshot = await getDoc(gameDocRef);
        if (!gameDocSnapshot.exists()) return;
        const currentGame = gameDocSnapshot.data();

        // 1. Localiza qual slot (posi√ß√£o na mesa) o jogador antigo ocupava
        const slotToUpdate = Object.keys(currentGame.selectedSlots).find(key => currentGame.selectedSlots[key] === oldPlayerId);
        if (!slotToUpdate) return;

        // 2. Atualiza os slots ativos e a lista de IDs na mesa
        const newSelectedSlots = { ...currentGame.selectedSlots, [slotToUpdate]: newPlayerId };
        const newPlayerIds = Object.values(newSelectedSlots);

        // 3. Gerencia Scores e Raios
        // Mantemos os pontos do jogador antigo no objeto para o hist√≥rico n√£o quebrar,
        // e inicializamos o novo jogador com 0.
        const newScores = { ...(currentGame.scores || {}) };
        newScores[newPlayerId] = 0;
        // Nota: N√ÉO deletamos o oldPlayerId daqui, para que os pontos dele continuem registrados na partida.

        const newRaios = { ...(currentGame.raios || {}) };
        newRaios[newPlayerId] = 0;

        // 4. HIST√ìRICO: N√ÉO alteramos os rounds passados!
        // Apenas criamos uma c√≥pia do hist√≥rico atual e adicionamos o evento de troca.
        const historyArray = [...(currentGame.history || [])];

        const swapEvent = {
            type: 'swap',
            roundNumber: historyArray.length + 1,
            playerOutId: oldPlayerId, // Guardamos o ID para an√°lise
            playerInId: newPlayerId,   // Guardamos o ID para an√°lise
            oldPlayerName: appState.players[oldPlayerId]?.name || 'Jogador Anterior',
            newPlayerName: appState.players[newPlayerId]?.name || 'Novo Jogador',
            timestamp: new Date(),
            // Salvamos o estado dos pontos no momento da troca
            stateScore: {
                scores: { ...newScores },
                raios: { ...newRaios }
            }
        };

        historyArray.push(swapEvent);

        // 5. Atualiza o turno se era do jogador que saiu
        let newTurn = currentGame.turn;
        if (newTurn === oldPlayerId) newTurn = newPlayerId;

        const updates = {
            selectedSlots: newSelectedSlots,
            playerIds: newPlayerIds,
            scores: newScores,
            raios: newRaios,
            history: historyArray,
            turn: newTurn
        };

        await updateDoc(gameDocRef, updates);
        showMessage("Troca realizada! O hist√≥rico original foi preservado.", "success");

    } catch (error) {
        console.error("Erro ao realizar a troca:", error);
        showMessage("Falha ao realizar a troca.", "error");
    }
}

async function endGame() {
    const currentGame = appState.gameState.activeGame;

    if (!currentGame || currentGame.history.length === 0) {
        resetGameState();
        switchView('view-scoreboard');
        return;
    }

    const modalHTML = `
        <h3 class="text-xl font-bold text-red-600">Encerrar Partida</h3>
        <p class="my-4">Tem certeza que deseja encerrar a partida? O jogador com mais raios (e pontos como desempate) ser√° declarado o vencedor.</p>
        <div class="flex justify-end gap-3 mt-6">
            <button id="confirmEndNo" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">N√£o, continuar</button>
            <button id="confirmEndYes" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition">Sim, encerrar</button>
        </div>`;
    openModal(modalHTML);

    document.getElementById('confirmEndYes').onclick = async () => {
        closeModal();

        // üî• JUIZ AO VIVO: Agora √© o "Irm√£o G√™meo" do analyzeMatchHistory
        let contagemRaios = {};
        let contagemPontos = {};

        if (currentGame.history && Array.isArray(currentGame.history)) {
            currentGame.history.forEach(round => {
                const pId = round.winnerId;

                // Exatamente igual ao seu hist√≥rico: conta vit√≥rias de rodadas
                if (round.type !== 'swap' && pId) {
                    contagemPontos[pId] = (contagemPontos[pId] || 0) + 1; // Soma 1 ponto (vit√≥ria)

                    if (round.completedRaio) {
                        contagemRaios[pId] = (contagemRaios[pId] || 0) + 1; // Soma 1 raio
                    }
                }
            });
        }

        let jogadoresStats = [];
        let absoluteMaxPoints = -1;
        let topScorerId = null;

        for (const playerId of currentGame.playerIds) {
            const playerPoints = contagemPontos[playerId] || 0;
            const playerRaios = contagemRaios[playerId] || 0;

            jogadoresStats.push({ id: playerId, raios: playerRaios, pontos: playerPoints });

            if (playerPoints > absoluteMaxPoints) {
                absoluteMaxPoints = playerPoints;
                topScorerId = playerId;
            }
        }

        // --- DETETIVE ---
        console.group("‚öñÔ∏è JUIZ DO FIM DA PARTIDA (G√™meo do Hist√≥rico)");
        console.table(jogadoresStats);
        console.groupEnd();

        jogadoresStats.sort((a, b) => {
            if (b.raios !== a.raios) return b.raios - a.raios;
            return b.pontos - a.pontos;
        });

        const primeiroLugar = jogadoresStats[0];
        const segundoLugar = jogadoresStats[1] || { raios: -1, pontos: -1 };
        const isTie = (primeiroLugar.raios === segundoLugar.raios && primeiroLugar.pontos === segundoLugar.pontos);

        if (!isTie && (primeiroLugar.raios > 0 || primeiroLugar.pontos > 0)) {
            const leaderId = primeiroLugar.id;
            let tanqueId = null;

            if (topScorerId !== leaderId) {
                tanqueId = topScorerId;
            } else if (topScorerId === leaderId && primeiroLugar.raios === segundoLugar.raios) {
                tanqueId = topScorerId;
            }

            const winnerInfo = { winnerId: leaderId };
            const finalGameData = {
                ...currentGame,
                status: 'finished',
                winnerInfo,
                maxRaios: primeiroLugar.raios,
                tanqueDeGuerraId: tanqueId,
                tanqueDeGuerraPoints: absoluteMaxPoints
            };

            await processAndShowGameOver(finalGameData);
        } else {
            const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
            await updateDoc(gameDocRef, { status: 'aborted', endedAt: serverTimestamp() });
            resetGameState();
            switchView('view-scoreboard');
            showMessage("Partida encerrada. Empate ou sem pontua√ß√£o.", "info");
        }
    };

    document.getElementById('confirmEndNo').onclick = () => closeModal();
}

let isProcessingGameOver = false;

async function processAndShowGameOver(gameData) {
    // üî• O CADEADO DE FERRO: Se j√° estiver processando ou a tela j√° estiver ativa, cai fora!
    if (isProcessingGameOver || document.getElementById('view-game-over').classList.contains('active')) {
        return;
    }
    isProcessingGameOver = true; // Tranca a porta!

    const { winnerInfo, tanqueDeGuerraId, tanqueDeGuerraPoints, maxRaios } = gameData;
    const batch = writeBatch(db);

    // 1. PREPARA OS DADOS PARA O FIREBASE
    let gameUpdateData = {
        status: 'finished',
        endedAt: serverTimestamp(),
        winnerInfo: winnerInfo || null,
        maxRaios: maxRaios || 0
    };

    if (tanqueDeGuerraId) {
        gameUpdateData.tanqueDeGuerraId = tanqueDeGuerraId;
        gameUpdateData.tanqueDeGuerraPoints = tanqueDeGuerraPoints;
    }

    const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
    batch.update(gameDocRef, gameUpdateData);

    // (O loop de atualizar jogadores foi removido com sucesso, o launchScore j√° cuida disso!)

    appState.gameState.finalGameData = gameData;

    // 2. ENVIA TUDO PARA O BANCO
    try {
        await batch.commit();
    } catch (error) {
        console.error("üî• Erro ao salvar no Firebase:", error);
    }

    // 3. CHAMA A SUA FUN√á√ÉO DE CONQUISTA (Agora blindada, s√≥ vai rodar UMA vez!)
    if (tanqueDeGuerraId) {
        const nomeDono = appState.players[tanqueDeGuerraId]?.name || 'Jogador';
        await concederConquista(
            tanqueDeGuerraId,
            'tanque_de_guerra',
            `üéñÔ∏è O trator passou! ${nomeDono} foi o Dono da Mesa acumulando ${tanqueDeGuerraPoints} pontos!`
        );
    }

    // 4. PREPARA OS TEXTOS DA TELA FINAL
    let winnerText = '';
    let finalScoreText = '';

    if (winnerInfo && winnerInfo.winnerId) {
        const nomeVencedor = appState.players[winnerInfo.winnerId]?.name || 'Desconhecido';
        winnerText = `üèÜ ${nomeVencedor}`;
        finalScoreText = `Venceu com ${maxRaios || 0} raios.`;
    } else {
        winnerText = "Empate";
        finalScoreText = "A partida terminou sem um vencedor isolado.";
    }

    // 5. MUDA A TELA E DESENHA
    resetGameState();
    switchView('view-game-over');

    ui.gameMode.gameOver.winnerText.textContent = winnerText;
    ui.gameMode.gameOver.scoreText.textContent = finalScoreText;

    if (tanqueDeGuerraId) {
        const nomeDono = appState.players[tanqueDeGuerraId]?.name || 'Desconhecido';
        ui.gameMode.gameOver.scoreText.innerHTML += `
            <div class="mt-6 p-4 bg-gradient-to-r from-yellow-100 to-yellow-50 text-yellow-800 rounded-xl border border-yellow-300 shadow-md mx-auto inline-block animate-bounce-in">
                <div class="text-3xl mb-1">üéñÔ∏è</div>
                <h4 class="font-bold text-lg uppercase tracking-wider text-yellow-900">Dono da Mesa</h4>
                <p class="text-md mt-1"><strong class="font-bold">${nomeDono}</strong> amassou com <strong>${tanqueDeGuerraPoints}</strong> vit√≥rias!</p>
            </div>
        `;
    }

    // Abre o cadeado depois de 2 segundos, para garantir que n√£o tranque futuras partidas
    setTimeout(() => { isProcessingGameOver = false; }, 2000);
}

// // Adicione esta fun√ß√£o tempor√°ria no seu c√≥digo
// async function limparSpamDeConquistas() {
//     console.log("Iniciando varredura para limpeza de eventos spam...");
//
//     try {
//         // ‚ö†Ô∏è PASSO 1: AJUSTE OS NOMES AQUI PARA BATER COM O SEU BANCO DE DADOS
//         // Troque 'eventos' pelo nome exato da cole√ß√£o onde os feeds de conquista ficam salvos
//         const caminhoExato = "artifacts/1:187178310074:web:5f56292dea8dc776532583/public/data/events";
//         const eventosRef = collection(db, caminhoExato);
//
//         // Substitua 'ID_DO_TESTE1' pelo ID real do jogador 'teste1'
//         const idDoJogador = "IjH5b9XpwaXRWdjY3XU7";
//
//         // Cria a busca: Pega todos os eventos do teste1 que sejam do tipo da conquista
//         // Ajuste os nomes dos campos ("playerId", "type") para como eles est√£o no seu banco
//         const q = query(
//             eventosRef,
//             // where("playerId", "==", idDoJogador),
//             where("player", "==", "teste1") // ou "roubo", dependendo de como voc√™ salva
//         );
//
//         const querySnapshot = await getDocs(q);
//
//         if (querySnapshot.empty) {
//             console.log("Nenhum evento spam encontrado! A faxina n√£o √© necess√°ria.");
//             return;
//         }
//
//         console.log(`Encontrados ${querySnapshot.size} eventos para deletar. Preparando a lixeira...`);
//
//         // Cria o lote de exclus√£o
//         const batch = writeBatch(db);
//         let contador = 0;
//
//         querySnapshot.forEach((documento) => {
//             // Se quiser salvar 1 evento para ele n√£o perder a conquista, podemos ignorar o primeiro
//             if (contador > 0) {
//                 batch.delete(documento.ref);
//             }
//             contador++;
//         });
//
//         // ‚ö†Ô∏è Importante: O Batch deleta no m√°ximo 500 por vez.
//         // Se o seu banco lotou com mais de 500, voc√™ precisar√° rodar essa fun√ß√£o algumas vezes.
//         await batch.commit();
//
//         console.log(`üßπ Faxina conclu√≠da com sucesso! Foram apagados ${contador - 1} eventos duplicados.`);
//         alert(`Limpeza finalizada! ${contador - 1} eventos exclu√≠dos.`);
//
//     } catch (error) {
//         console.error("üî• Erro durante a faxina:", error);
//     }
// }
// let limpeza = true;
// if (limpeza) {
//     limparSpamDeConquistas();
//     limpeza = false;
// }
function switchView(viewId) { ui.views.forEach(v => v.classList.toggle('active', v.id === viewId)); }

function renderScoreboard() {
    const players = Object.values(appState.players);
    const seriesOrder = ['A', 'B', 'C', 'D', 'Amador'];

    players.sort((a, b) => {
        const statsA = a[currentSeason] || {};
        const statsB = b[currentSeason] || {};

        const aproveitamentoDiff = (statsB.aproveitamentoNaTemporada || 0) - (statsA.aproveitamentoNaTemporada || 0);
        if (aproveitamentoDiff !== 0) return aproveitamentoDiff;

        const pontosDiff = (statsB.pontosNaTemporada || 0) - (statsA.pontosNaTemporada || 0);
        if (pontosDiff !== 0) return pontosDiff;

        return (statsA.lambretasNaTemporada || 0) - (statsB.lambretasNaTemporada || 0);
    });

    ui.playersListDiv.innerHTML = players.map((player, index) => {
        const stats = player[currentSeason] || {};

        let cardClasses = "p-4 rounded-xl shadow-sm flex items-center justify-between transition-all duration-200 hover:scale-[1.01]";
        let positionIcon = "";
        let positionText = `${index + 1}¬∫`;

        if (index < 3) {
            cardClasses += " bg-green-50 border-l-4 border-green-500";
            positionIcon = ["ü•á", "ü•à", "ü•â"][index] || "";
        } else if (index >= players.length - 3) {
            cardClasses += " bg-red-50 border-l-4 border-red-500";
        } else {
            cardClasses += " bg-white";
        }

        if (index === 0) {
            cardClasses += " ring-2 ring-yellow-400 animate-pulse";
            positionText = "üëë " + positionText;
        }

        return `
            <div class="${cardClasses}">
                <div class="flex items-center gap-3">
                    <span class="font-mono text-sm text-gray-400 w-8 text-center">
                        ${positionIcon || positionText}
                    </span>
                    <div>
                        <span class="font-bold text-lg player-name-clickable" data-player-id="${player.id}">
                            ${player.name}
                        </span>
                        <span class="text-sm text-gray-500 ml-2">
                            (S√©rie ${player.series})
                        </span>
                    </div>
                </div>
                <div class="text-sm font-mono leading-tight text-right">
                    <div class="grid grid-cols-4 text-gray-500 w-44 mx-auto">
                        <span class="text-center">RT</span>
                        <span class="text-center">LT</span>
                        <span class="text-center">PAT</span>
                        <span class="text-center">AT</span>
                    </div>
                    <div class="grid grid-cols-4 font-semibold w-44 mx-auto">
                        <span class="text-blue-600 text-center">${stats.raiosNaTemporada || 0}</span>
                        <span class="text-yellow-600 text-center">${stats.lambretasNaTemporada || 0}</span>
                        <span class="text-center">${stats.partidasNaTemporada || 0}</span>
                        <span class="text-center">${(stats.aproveitamentoNaTemporada || 0).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
        `;

    }).join('');
}

async function atualizarAproveitamentoTemporada(playerId) {
    const playerRef = doc(playersCollectionRef(), playerId);
    const playerSnap = await getDoc(playerRef);
    if (!playerSnap.exists()) return;

    const player = playerSnap.data();
    const stats = player[currentSeason] || {};
    let peso = 50;
    // const aproveitamentoRA = stats.partidasNaTemporada > 0 ? (stats.raiosNaTemporada / stats.partidasNaTemporada) * 100 : 0;
    // const aproveitamentoLB = stats.partidasNaTemporada > 0 ? (stats.lambretasNaTemporada / stats.partidasNaTemporada) * 100: 0;
    // Garantimos que todos os valores sejam n√∫meros, usando || 0 para campos inexistentes
    const partidas = stats.partidasNaTemporada || 0;
    const raios = stats.raiosNaTemporada || 0;
    const lambretas = stats.lambretasNaTemporada || 0;

    if (raios === 0) peso = 0;

    // Agora o c√°lculo fica blindado contra NaN
    const aproveitamentoRA = partidas > 0 ? (raios / partidas) * 100 : 0;
    const aproveitamentoLB = partidas > 0 ? (lambretas / partidas) * 100 : 0;

    // F√≥rmula final
    // Aproveitamento agora passa pelo peso dos raios e das lambretas.
    const aproveitamento = peso - aproveitamentoLB + aproveitamentoRA;

    await updateDoc(playerRef, {
        [`${currentSeason}.aproveitamentoNaTemporada`]: aproveitamento
    });
}

async function concederConquista(playerId, conquistaId, textoDoEvento) {
    const player = appState.players[playerId];
    const playerDocRef = doc(playersCollectionRef(), playerId);

    // Para conquistas de uma s√≥ vez, como 'primeiro_rei', a verifica√ß√£o
    // deve ser feita ANTES de chamar esta fun√ß√£o.
    // Esta fun√ß√£o agora SEMPRE incrementa o contador.

    try {
        // Usa a nota√ß√£o de ponto para atualizar um campo dentro de um objeto (mapa)
        // e a fun√ß√£o increment() para adicionar +1 de forma segura.
        await updateDoc(playerDocRef, {
            [`conquistas.${conquistaId}`]: increment(1),
            [`${currentSeason}.conquistasNaTemporada.${conquistaId}`]: increment(1)
        });


        // Registra o feito no feed de atividades
        await registrarEvento('achievement', playerId, textoDoEvento);

        showMessage(`${player.name} ${textoDoEvento}`, 'success');

    } catch (error) {
        console.error("Erro ao conceder conquista:", error);
        showMessage("Erro ao processar conquista.", "error");
    }
}

function showGameSummary() {
    const gameHistory = appState.gameState.finalGameData.history;
    if (!gameHistory || gameHistory.length === 0) return;

    let summaryHTML = `<h3 class="text-2xl font-bold mb-4">Resumo da Partida</h3><div class="space-y-4 max-h-96 overflow-y-auto">`;

    gameHistory.forEach(round => {
        const winnerName = appState.players[round.winnerId].name;
        summaryHTML += `
            <div class="bg-gray-50 p-3 rounded-lg">
                <p class="font-bold text-lg">Rodada ${round.roundNumber}: <span class="text-blue-600">${winnerName}</span> venceu</p>
                ${round.completedRaio ? '<p class="text-sm font-semibold text-yellow-600">‚ö°Ô∏è RAIO COMPLETO! ‚ö°Ô∏è</p>' : ''}
                <div class="text-xs text-gray-600 mt-2">
                    <p>Placar de Raios: ${Object.entries(round.stateScore.raios).map(([pid, r]) => `${appState.players[pid].name}: ${r}`).join(', ')}</p>
                    <p>Placar de Pontos: ${Object.entries(round.stateScore.scores).map(([pid, s]) => `${appState.players[pid].name}: ${s}`).join(', ')}</p>}
                </div>
            </div>
        `;
    });

    summaryHTML += `</div>`;
    openModal(summaryHTML);
}

async function registrarEvento(type, playerId, text) {
    try {
        const player = appState.players[playerId];
        if (!player) {
            console.error("Tentativa de registrar evento para jogador desconhecido:", playerId);
            return;
        }

        const eventData = {
            type: type, // 'promotion', 'demotion', 'achievement'
            player: player.name,
            text: text,
            timestamp: serverTimestamp()
        };
        await addDoc(activityFeedCollectionRef(), eventData);
    } catch (error) {
        console.error("Erro ao registrar evento:", error);
    }
}

function renderActivityFeed() {
    ui.activityFeedDiv.innerHTML = appState.activityFeed.length === 0 ? '<p class="text-gray-500 text-center">Nenhuma atividade recente.</p>' :
        appState.activityFeed.map(item => {
            let icon = 'üí¨';
            if (item.type === 'promotion') icon = '‚ñ≤';
            else if (item.type === 'demotion') icon = '‚ñº';
            else if (item.type === 'stagnant') icon = 'üìç';
            else if (item.type === 'achievement') icon = '‚≠ê';
            const color = item.type === 'promotion' ? 'green' : (item.type === 'demotion' ? 'red' : 'yellow');
            const timestamp = item.timestamp?.seconds ? new Date(item.timestamp.seconds * 1000).toLocaleString('pt-BR') : 'agora';
            return `<div class="p-3 rounded-lg flex items-center gap-3"><span class="text-${color}-500">${icon}</span><div><p class="text-gray-800"><span class="font-semibold">${item.player}</span> ${item.text}</p><p class="text-xs text-gray-400">${timestamp}</p></div></div>`;
        }).join('');
}

function renderVisualScoreboard(gameData) {
    const scoreboardDiv = document.getElementById('liveMatchScoreboard');
    if (!scoreboardDiv) return;

    const { playerIds, scores, raios } = gameData;
    let scoreboardHTML = '';

    playerIds.forEach(playerId => {
        const player = appState.players[playerId];
        if (!player) return;

        const currentPontos = scores?.[playerId] || 0;
        const currentRaios = raios?.[playerId] || 0;

        // Gera os 4 c√≠rculos de pontos
        let pointsHTML = '';
        for (let i = 1; i <= 4; i++) {
            const pointColor = i <= currentPontos ? 'bg-yellow-400' : 'bg-gray-300';
            pointsHTML += `<div class="w-4 h-4 rounded-full ${pointColor} border-2 border-white"></div>`;
        }

        // Gera o contador de raios
        const raioCounterHTML = currentRaios > 1 ? `
            <span class="ml-1 text-sm font-bold text-yellow-700">(x${currentRaios})</span>
        ` : '';

        const raiosDisplayHTML = currentRaios > 0 ? `
            <div class="flex items-center justify-center text-2xl mt-2">
                <span>‚ö°Ô∏è</span>
                ${raioCounterHTML}
            </div>
        ` : '<div class="h-9"></div>'; // Espa√ßo reservado para manter a altura

        scoreboardHTML += `
            <div class="bg-gray-50 p-2 rounded-lg text-center shadow">
                <p class="font-bold text-sm truncate">${player.name}</p>
                <div class="flex justify-center items-center gap-1.5 my-2">
                    ${pointsHTML}
                </div>
                ${raiosDisplayHTML}
            </div>
        `;
    });

    scoreboardDiv.innerHTML = scoreboardHTML;
}

function renderHistoryFeed(gameData) {
    const historyDiv = document.getElementById('liveMatchHistory');
    if (!historyDiv) return;

    const history = gameData.history || [];
    if (history.length === 0) {
        historyDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Aguardando a primeira rodada...</p>';
        return;
    }

    // REMOVEMOS o .slice(-5). Agora pegamos tudo e apenas invertemos para o mais novo ficar no topo.
    const fullHistoryReversed = [...history].reverse();

    historyDiv.innerHTML = fullHistoryReversed.map(round => {
        let eventHTML = '';

        if (round.type === 'swap') {
            eventHTML = `
                <p class="text-gray-800 text-sm italic">
                    Troca de jogadores üîÑ Saiu <span class="font-semibold">${round.oldPlayerName}</span> e entrou <span class="font-semibold">${round.newPlayerName}</span>.
                </p>`;
        } else {
            const winnerName = appState.players[round.winnerId]?.name || 'Desconhecido';
            let roundText = round.completedRaio ?
                `ganhou um <strong>Raio! ‚ö°Ô∏è</strong>` :
                `marcou um ponto.`;

            eventHTML = `
                <p class="text-sm text-gray-800">
                    <span class="font-semibold text-gray-400">Rod. ${round.roundNumber}:</span>
                    <span class="font-bold">${winnerName}</span> ${roundText}
                </p>`;
        }

        return `<div class="p-2 border-t border-gray-50 first:border-t-0 hover:bg-gray-50 transition-colors">${eventHTML}</div>`;
    }).join('');
}

function renderLiveMatchFeed(gameData) {
    const feedContainer = document.getElementById('liveMatchFeed');
    if (!feedContainer) return;

    // Adicionamos as classes de scroll e altura m√°xima no container do hist√≥rico
    feedContainer.innerHTML = `
        <div id="liveMatchScoreboard" class="grid grid-cols-2 md:grid-cols-4 gap-2 pb-4 border-b border-gray-200">
        </div>
        <div id="liveMatchHistory" class="pt-2 max-h-48 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300">
        </div>
    `;

    renderVisualScoreboard(gameData);
    renderHistoryFeed(gameData);
}

function openModal(html) {
    ui.modal.content.innerHTML = html;

    // Mostra o container
    ui.modal.container.style.display = 'block'; // Usando block para o overflow-y funcionar melhor

    // TRAVA O SCROLL DO FUNDO
    document.body.classList.add('modal-open');

    // Esconde o bot√£o flutuante (FAB)
    const fabContainer = document.querySelector('.admin-fab-container');
    if (fabContainer) fabContainer.classList.add('hidden');

    // Garante que o modal comece no topo ao abrir
    ui.modal.container.scrollTop = 0;
}

function closeModal() {
    ui.modal.container.style.display = 'none';
    ui.modal.content.innerHTML = '';

    // DESTRAVA O SCROLL DO FUNDO
    document.body.classList.remove('modal-open');

    // Mostra novamente o FAB
    const fabContainer = document.querySelector('.admin-fab-container');
    if (fabContainer) fabContainer.classList.remove('hidden');
}

async function updatePlayerStat(playerId, stat, amount) {
    if (!appState.isAdminMode) return;

    const playerDocRef = doc(playersCollectionRef(), playerId);

    try {
        const playerDoc = await getDoc(playerDocRef);
        if (!playerDoc.exists()) {
            showMessage("Erro: Jogador n√£o encontrado.", "error");
            return;
        }
        const player = playerDoc.data();

        const updates = {};

        // --- IN√çCIO DA CORRE√á√ÉO ---
        // L√≥gica corrigida para lidar com o plural de "lambreta"
        let seriesStatName = '';
        if (stat === 'lambreta') {
            seriesStatName = 'lambretasNaSerie';
        } else {
            seriesStatName = `${stat}NaSerie`;
        }
        // --- FIM DA CORRE√á√ÉO ---

        const currentStatValue = player[stat] || 0;
        const currentSeriesValue = player[seriesStatName] || 0;

        if (currentStatValue + amount < 0) {
            showMessage(`N√£o √© poss√≠vel ter valor negativo para ${stat}.`, 'error');
            return;
        }

        updates[stat] = increment(amount);

        if (currentSeriesValue + amount >= 0) {
            updates[seriesStatName] = increment(amount);
        } else {
            updates[seriesStatName] = -1;
            // console.warn(`Contador de s√©rie para "${stat}" j√° est√° em 0.`);
        }

        if (Object.keys(updates).length > 0) {
            await updateDoc(playerDocRef, updates);
        }

        // const changes = await checarStatusDaSerie(playerId);
        // await applySeriesChanges(playerId, changes);

    } catch (error) {
        console.error(`Erro ao atualizar ${stat}:`, error);
        showMessage(`Erro ao atualizar ${stat}.`, 'error');
    }
}

function openPlayerDetailsModal(playerId) {
    appState.modalContext = { currentViewedPlayerId: playerId };
    const player = appState.players[playerId];
    if (!player) return;

    const s = player[currentSeason] || {};

    // --- 1. C√ÅLCULOS GLOBAIS ---
    const totalPartidas = player.partidasJogadas || 0;
    const aprovRaiosGlobal = totalPartidas > 0 ? ((player.raios / totalPartidas) * 100).toFixed(1) : "0";
    const aprovLambretasGlobal = totalPartidas > 0 ? ((player.lambreta / totalPartidas) * 100).toFixed(1) : "0";

    // --- 2. C√ÅLCULOS DA TEMPORADA ---
    const partidasTemporada = s.partidasNaTemporada || 0;
    const aprovRaiosTemp = partidasTemporada > 0 ? (((s.raiosNaTemporada || 0) / partidasTemporada) * 100).toFixed(1) : "0";
    const aprovLambTemp = partidasTemporada > 0 ? (((s.lambretasNaTemporada || 0) / partidasTemporada) * 100).toFixed(1) : "0";

    // --- 3. GALERIA DE TROF√âUS (GERAL) ---
    const achievementsHTML = Object.keys(achievements).map(key => {
        const ach = achievements[key];
        const countGeral = player.conquistas?.[key] || 0;
        const countTemporada = s.conquistasNaTemporada?.[key] || 0;
        const countTotal = countGeral + countTemporada;

        if (countTotal === 0) return '';

        const counterHTML = countTotal > 1
            ? `<span class="absolute -top-1 -right-1 bg-red-600 text-white text-[9px] font-bold rounded-full h-4 w-4 flex items-center justify-center border border-white">${countTotal}</span>`
            : '';

        return `
            <div class="relative flex flex-col items-center bg-gray-50 p-2 rounded-xl border border-gray-100 min-w-[65px]">
                <span class="text-2xl" title="${ach.description}">${ach.icon}</span>
                <p class="text-[8px] font-bold text-gray-500 uppercase mt-1 text-center leading-tight">${ach.name}</p>
                ${counterHTML}
            </div>`;
    }).join('');

    // --- 4. CONQUISTAS ESPEC√çFICAS DA TEMPORADA (DETALHADO) ---
    const conquistasTemporadaHTML = s.conquistasNaTemporada && Object.keys(s.conquistasNaTemporada).length > 0
        ? Object.keys(s.conquistasNaTemporada).map(key => {
            const ach = achievements[key]; // Busca no dicion√°rio global pelo ID que est√° na temporada
            if (!ach) return '';
            return `
                <div class="bg-green-50 px-2 py-1 rounded border border-green-100 flex items-center gap-1">
                    <span class="text-sm">${ach.icon}</span>
                    <span class="text-[8px] font-bold text-green-700 uppercase">${ach.name}</span>
                </div>`;
        }).join('')
        : '<p class="text-[10px] text-gray-400 italic">Nenhum trof√©u nesta temporada ainda...</p>';

    const generateStatControlHTML = (stat, label) => {
        const value = player[stat] || 0;
        return `
            <div class="bg-gray-50 p-2 rounded-lg border border-gray-100 font-mono">
                <p class="text-[9px] uppercase font-bold text-gray-400 mb-1">${label}</p>
                <div class="flex items-center justify-between">
                    <span class="text-lg font-bold text-gray-700">${value}</span>
                    ${appState.isAdmin ? `
                        <div class="flex gap-1">
                            <button onclick="updateStat('${playerId}', '${stat}', -1)" class="w-5 h-5 bg-red-100 text-red-600 rounded flex items-center justify-center text-xs">-</button>
                            <button onclick="updateStat('${playerId}', '${stat}', 1)" class="w-5 h-5 bg-green-100 text-green-600 rounded flex items-center justify-center text-xs">+</button>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    };

    const modalHTML = `
        <div class="flex justify-between items-start mb-4">
            <div>
                <h3 class="text-2xl font-bold text-gray-800">${player.name}</h3>
                <p class="text-[10px] text-blue-600 uppercase tracking-widest font-black">Performance Geral</p>
            </div>
            <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-3xl">&times;</button>
        </div>

        <div class="grid grid-cols-2 gap-3 mb-6">
            <div class="bg-gradient-to-br from-yellow-50 to-orange-50 border border-yellow-100 p-3 rounded-xl">
                <p class="text-[9px] uppercase font-black text-yellow-700">Aprov. Raios Global</p>
                <p class="text-2xl font-black text-yellow-900">${aprovRaiosGlobal}%</p>
            </div>
            <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-100 p-3 rounded-xl">
                <p class="text-[9px] uppercase font-black text-blue-700">Aprov. Lambretas Global</p>
                <p class="text-2xl font-black text-blue-900">${aprovLambretasGlobal}%</p>
            </div>
        </div>

        <div class="mb-6 px-1">
            <h4 class="text-[10px] font-black text-gray-400 uppercase mb-2">Galeria de Trof√©us</h4>
            <div class="flex flex-wrap gap-2">
                ${achievementsHTML || '<p class="text-xs text-gray-300 italic font-medium">Nenhum trof√©u ainda.</p>'}
            </div>
        </div>

        <div class="bg-white border-t-2 border-green-500 rounded-2xl p-4 mb-6 shadow-sm border border-gray-100">
            <h4 class="text-xs font-black text-gray-700 uppercase mb-3 flex justify-between items-center">
                <span>Temporada Atual</span>
                <span class="bg-green-100 text-green-700 px-2 py-0.5 rounded text-[9px] font-black">${currentSeason}</span>
            </h4>

            <div class="grid grid-cols-4 text-[9px] text-gray-400 uppercase font-bold text-center mb-1">
                <span>Lamb.</span><span>Raios</span><span>Part.</span><span>MP</span>
            </div>
            <div class="grid grid-cols-4 font-bold text-gray-800 text-center mb-4 border-b border-gray-50 pb-2 font-mono">
                <span class="text-blue-600">${s.lambretasNaTemporada || 0}</span>
                <span class="text-yellow-600">${s.raiosNaTemporada || 0}</span>
                <span>${s.partidasNaTemporada || 0}</span>
                <span>${s.matchPointsNaTemporada || 0}</span>
            </div>

            <div class="space-y-4 mb-5">
                <div>
                    <div class="flex justify-between text-[10px] font-bold uppercase mb-1">
                        <span class="text-gray-500">Aprov. Raios (Temp.)</span>
                        <span class="text-yellow-600">${aprovRaiosTemp}%</span>
                    </div>
                    <div class="w-full bg-gray-100 h-1.5 rounded-full overflow-hidden">
                        <div class="bg-yellow-500 h-full" style="width: ${aprovRaiosTemp}%"></div>
                    </div>
                </div>
                <div>
                    <div class="flex justify-between text-[10px] font-bold uppercase mb-1">
                        <span class="text-gray-500">Aprov. Lambretas (Temp.)</span>
                        <span class="text-blue-600">${aprovLambTemp}%</span>
                    </div>
                    <div class="w-full bg-gray-100 h-1.5 rounded-full overflow-hidden">
                        <div class="bg-blue-600 h-full" style="width: ${aprovLambTemp}%"></div>
                    </div>
                </div>
            </div>

            <h5 class="text-[9px] font-black text-gray-400 uppercase mb-2">Conquistado nesta temporada:</h5>
            <div class="flex flex-wrap gap-2">
                ${conquistasTemporadaHTML}
            </div>
        </div>

        <h4 class="text-[10px] font-black text-gray-400 uppercase mb-2 px-1">Totais de Carreira</h4>
        <div class="grid grid-cols-2 gap-2 mb-4">
            ${generateStatControlHTML('partidasJogadas', 'Partidas')}
            ${generateStatControlHTML('raios', 'Raios')}
            ${generateStatControlHTML('lambreta', 'Lambretas')}
            ${generateStatControlHTML('pontos', 'Pontos')}
        </div>

        ${appState.isAdminMode ? `
            <div class="mt-6 pt-4 border-t border-gray-100">
                <button onclick="deletarJogador('${playerId}')"
                        class="w-full bg-red-50 text-red-600 py-3 rounded-xl font-bold text-xs uppercase tracking-widest hover:bg-red-100 transition-colors">
                    EXCLUIR JOGADOR
                </button>
            </div>
        ` : ''}
    `;

    openModal(modalHTML);
    document.getElementById('modal-close-btn').onclick = closeModal;
}

function createInitialGameState() { return { gameMode: 'individual', selectedSlots: { 1: null, 2: null, 3: null, 4: null }, activeGame: null, activeGameId: null, activeGameListener: null }; }

function resetGameState() {
    if (appState.gameState.activeGameListener) {
        appState.gameState.activeGameListener();
    }

    // --- IN√çCIO DA CORRE√á√ÉO ---
    // 1. Salva a refer√™ncia aos dados do jogo final, se eles existirem.
    const finalData = appState.gameState.finalGameData;

    // 2. Cria o novo estado de jogo limpo, como antes.
    appState.gameState = createInitialGameState();

    // 3. Se havia dados de um jogo final, restaura eles no novo estado.
    if (finalData) {
        appState.gameState.finalGameData = finalData;
    }
    // --- FIM DA CORRE√á√ÉO ---

    // O resto da fun√ß√£o continua igual, limpando a interface.
    ui.gameMode.statusText.textContent = 'Selecione os jogadores para come√ßar';
    ui.gameMode.startBtn.style.display = 'block';
    ui.gameMode.activeButtons.style.display = 'none';
    updateGameModeUI();
}

// 1. Limpamos a fun√ß√£o pois os bot√µes de modo n√£o existem mais.
// Agora ela s√≥ garante que o modo √© individual e reseta a mesa.
function updateGameModeUI() {
    appState.gameState.gameMode = 'individual';
    resetPlayerSlots();
}

function resetPlayerSlots() {
    appState.gameState.selectedSlots = { 1: null, 2: null, 3: null, 4: null };
    renderAllSlots();
}

function renderAllSlots() {
    // Procura todas as divs de slot na mesa e renderiza cada uma
    document.querySelectorAll('.player-slot').forEach(slot => {
        const slotId = slot.id.split('-')[1];
        renderPlayerSlot(slotId);
    });
    checkStartGameCondition();
}

function renderPlayerSlot(slotId) {
    const slotDiv = document.getElementById(`slot-${slotId}`);

    // Determina se estamos apenas montando a mesa ou se o jogo j√° est√° valendo
    const slotsSource = appState.gameState.activeGame ? appState.gameState.activeGame.selectedSlots : appState.gameState.selectedSlots;
    const playerId = slotsSource?.[slotId];
    const player = playerId ? appState.players[playerId] : null;

    slotDiv.innerHTML = ''; // Limpa o conte√∫do anterior

    if (player) {
        let scoreHTML = '';

        // Se um jogo est√° ativo, busca os dados de placar
        if (appState.gameState.activeGame) {
            const gameData = appState.gameState.activeGame;
            const raios = gameData.raios?.[playerId] || 0;
            const pontos = gameData.scores?.[playerId] || 0;

            // Verifica se a fun√ß√£o generateScoreHTML existe no seu c√≥digo, sen√£o exibe apenas os pontos
            if(typeof generateScoreHTML === 'function') {
                scoreHTML = generateScoreHTML(raios, pontos);
            } else {
                scoreHTML = `<span class="font-bold text-blue-600">${pontos} pts</span>`;
            }
        }

        // Desenha o jogador sentado na mesa
        slotDiv.innerHTML = `
            <div class="bg-white p-3 rounded-lg shadow-md text-center w-24 sm:w-32 transition-all transform hover:scale-105 cursor-pointer" onclick="openPlayerSelectionModal('${slotId}')" title="Clique para trocar o jogador">
                <div class="font-bold text-sm sm:text-base truncate text-gray-800">${player.name}</div>
                <div id="score-${slotId}" class="flex flex-wrap justify-center items-center gap-1 mt-1 min-h-[20px] text-lg">
                    ${scoreHTML}
                </div>
            </div>
        `;
    } else {
        // Desenha o bot√£o "+" se o assento estiver vazio
        slotDiv.innerHTML = `
            <button class="add-player-btn w-16 h-16 sm:w-20 sm:h-20 bg-white/30 border-2 border-dashed border-white/60 rounded-full flex items-center justify-center text-4xl text-white hover:bg-white/50 hover:scale-105 transition shadow-sm mx-auto" data-slot-id="${slotId}">
                +
            </button>
        `;

        // Adiciona o evento de clique no "+" rec√©m-criado
        slotDiv.querySelector('.add-player-btn').addEventListener('click', () => openPlayerSelectionModal(slotId));
    }
}

function openPlayerSelectionModal(slotId) {
    // Impede de trocar jogador se a partida j√° estiver rolando
    if (appState.gameState.activeGame) return;

    appState.gameState.targetSlot = slotId;

    // Filtra para mostrar apenas jogadores que AINDA N√ÉO est√£o sentados na mesa
    const selectedIds = Object.values(appState.gameState.selectedSlots).filter(Boolean);
    const availablePlayers = Object.values(appState.players).filter(p => !selectedIds.includes(p.id));

    // Monta o visual do Modal
    const modalHTML = `
        <h3 class="text-xl font-bold mb-4 text-center text-gray-800">Selecione um Jogador</h3>
        <div class="space-y-2 max-h-[60vh] overflow-y-auto pr-2">
            ${availablePlayers.length > 0
                ? availablePlayers.map(p => `
                    <button class="w-full text-left p-3 bg-gray-50 border border-gray-200 rounded-lg hover:bg-blue-50 hover:border-blue-300 transition player-select-btn font-medium text-gray-700" data-player-id="${p.id}">
                        ${p.name}
                    </button>
                  `).join('')
                : '<p class="text-center text-gray-500 py-4">Todos os jogadores j√° est√£o na mesa.</p>'
            }
        </div>
        <button id="modal-cancel-btn" class="mt-4 bg-red-100 text-red-700 hover:bg-red-200 font-semibold py-3 px-4 rounded-lg w-full transition">Cancelar</button>
    `;

    openModal(modalHTML);

    // ATEN√á√ÉO: √â vital adicionar os eventos de clique AP√ìS o modal ser aberto no DOM!
    document.querySelectorAll('.player-select-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            selectPlayer(e.currentTarget.dataset.playerId);
        });
    });

    document.getElementById('modal-cancel-btn').addEventListener('click', closeModal);
}

function selectPlayer(playerId) {
    // Se o jogador escolhido j√° estiver em outro slot (fallback de seguran√ßa), tira ele de l√°
    const currentSlotOfPlayer = Object.keys(appState.gameState.selectedSlots).find(key => appState.gameState.selectedSlots[key] === playerId);
    if (currentSlotOfPlayer) {
        appState.gameState.selectedSlots[currentSlotOfPlayer] = null;
    }

    // Coloca o jogador no slot desejado
    appState.gameState.selectedSlots[appState.gameState.targetSlot] = playerId;

    closeModal();
    renderAllSlots(); // Atualiza a mesa
}

function checkStartGameCondition() {
    // Conta quantos slots est√£o preenchidos
    const selectedCount = Object.values(appState.gameState.selectedSlots).filter(Boolean).length;

    // O jogo s√≥ come√ßa se os 4 assentos estiverem ocupados
    const canStart = (selectedCount === 4);

    // Atualiza o bot√£o visualmente
    ui.gameMode.startBtn.disabled = !canStart;
    ui.gameMode.startBtn.className = canStart
        ? 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg shadow-md transition transform hover:scale-105'
        : 'bg-gray-400 text-white font-bold py-3 px-8 rounded-lg shadow-md cursor-not-allowed';
}

function processMessageQueue() {
    // Se uma mensagem j√° estiver na tela, ou se a fila estiver vazia, n√£o faz nada.
    if (appState.isMessageShowing || appState.messageQueue.length === 0) {
        return;
    }

    // Marca que a tela est√° "ocupada" mostrando uma mensagem.
    appState.isMessageShowing = true;

    // Pega a primeira mensagem da fila.
    const messageData = appState.messageQueue.shift();
    const messageBox = ui.messageBox;

    let baseClasses = 'fixed left-1/2 -translate-x-1/2 w-auto min-w-[320px] max-w-[90%] py-3 px-5 rounded-lg shadow-2xl text-white font-semibold z-[1002] transition-all duration-500 ease-in-out';
    let typeClasses = '';

    switch (messageData.type) {
        case 'success': typeClasses = 'bg-green-600'; break;
        case 'error': typeClasses = 'bg-red-600'; break;
        default: typeClasses = 'bg-blue-600'; break;
    }

    // Mostra a mensagem
    messageBox.className = `${baseClasses} ${typeClasses} -top-24`;
    messageBox.textContent = messageData.text;
    messageBox.style.display = 'block';

    // Anima√ß√£o de entrada
    setTimeout(() => {
        messageBox.classList.remove('-top-24');
        messageBox.classList.add('top-5');
    }, 50);

    // Agenda a anima√ß√£o de sa√≠da e a limpeza
    setTimeout(() => {
        messageBox.classList.remove('top-5');
        messageBox.classList.add('-top-24');

        // Espera a anima√ß√£o de sa√≠da terminar
        setTimeout(() => {
            messageBox.style.display = 'none';
            // Libera a tela para a pr√≥xima mensagem
            appState.isMessageShowing = false;
            // Chama a si mesma para verificar se h√° mais mensagens na fila
            processMessageQueue();
        }, 500); // Deve ser igual √† dura√ß√£o da transi√ß√£o CSS

    }, 4000); // Tempo que a mensagem fica vis√≠vel
}

function showMessage(message, type = 'info') {
    // Adiciona o objeto da mensagem na nossa fila de espera.
    appState.messageQueue.push({ text: message, type: type });
    // Tenta processar a fila. Se a tela estiver livre, a mensagem ser√° exibida.
    // Se n√£o, ela esperar√° sua vez.
    processMessageQueue();
}

async function addNovoJogador() {
    if (!appState.isAdminMode) {
        showMessage("Voc√™ precisa estar no Modo Administrador para adicionar jogadores.", 'error');
        return;
    }

    // 1. Construir o HTML do modal usando as classes TailwindCSS do seu projeto.
    const modalHTML = `
        <div class="flex justify-between items-start">
            <h3 class="text-2xl font-bold">Adicionar Novo Jogador</h3>
            <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
        </div>
        <div class="mt-4">
            <label for="newPlayerNameInput" class="block text-sm font-medium text-gray-700 mb-1">Nome do Jogador</label>
            <input type="text" id="newPlayerNameInput" placeholder="Digite o nome aqui" class="w-full border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
        </div>
        <div class="mt-6 flex justify-end gap-3">
            <button id="cancelAddPlayerBtn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">Cancelar</button>
            <button id="saveAddPlayerBtn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Adicionar Jogador</button>
        </div>
    `;

    // 2. Abrir o modal padr√£o da aplica√ß√£o com o conte√∫do criado.
    openModal(modalHTML);

    const newPlayerNameInput = document.getElementById('newPlayerNameInput');
    newPlayerNameInput.focus(); // Foco autom√°tico no campo de input.

    // 3. Adicionar os event listeners para os novos bot√µes dentro do modal.
    document.getElementById('saveAddPlayerBtn').onclick = async () => {
        const newName = newPlayerNameInput.value.trim();
        if (newName) {
            try {
                await addDoc(playersCollectionRef(), {
                    name: newName,
                    raios: 0,
                    partidasJogadas: 0,
                    lambreta: 0,
                    pontos: 0,
                    series: 'D',
                    conquistas: {},
                    [currentSeason]: {
                    lambretasNaTemporada: 0,
                    raiosNaTemporada: 0,
                    pontosNaTemporada: 0,
                    matchPointsNaTemporada: 0,
                    partidasNaTemporada: 0,
                    conquistasNaTemporada:{}
                    }

                });
                // A fun√ß√£o showMessage continua sendo usada para feedback r√°pido no topo da tela.
                showMessage(`Jogador "${newName}" adicionado com sucesso!`, 'success');
                closeModal(); // Fecha o modal ap√≥s o sucesso.
            } catch (error) {
                console.error("Erro ao adicionar jogador:", error);
                showMessage("Erro ao adicionar jogador. Tente novamente.", 'error');
            }
        } else {
            showMessage("O nome do jogador n√£o pode ser vazio.", 'error');
        }
    };

    // O bot√£o de cancelar agora tamb√©m usa a fun√ß√£o padr√£o de fechar.
    document.getElementById('cancelAddPlayerBtn').onclick = () => {
        closeModal();
    };
}

async function renomearJogador(playerId) {
    if (!appState.isAdminMode) {
        showMessage("A√ß√£o n√£o permitida.", 'error');
        return;
    }
    const player = appState.players[playerId];
    const playerDocRef = doc(playersCollectionRef(), playerId);

    // Usa o sistema de modal padr√£o
    const modalHTML = `
        <div class="flex justify-between items-start">
            <h3 class="text-2xl font-bold">Renomear Jogador</h3>
            <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
        </div>
        <div class="mt-4">
            <label for="reNamePlayerInput" class="block text-sm font-medium text-gray-700 mb-1">Novo nome para ${player.name}</label>
            <input type="text" id="reNamePlayerInput" value="${player.name}" class="w-full border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
        </div>
        <div class="mt-6 flex justify-end gap-3">
            <button id="cancelRenamePlayerBtn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">Cancelar</button>
            <button id="saveRenamePlayerBtn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Salvar Altera√ß√µes</button>
        </div>`;
    openModal(modalHTML);

    const reNamePlayerInput = document.getElementById('reNamePlayerInput');
    reNamePlayerInput.focus();
    reNamePlayerInput.select();

    document.getElementById('saveRenamePlayerBtn').onclick = async () => {
        const newName = reNamePlayerInput.value.trim();
        if (newName && newName !== player.name) {
            try {
                await updateDoc(playerDocRef, { name: newName });
                showMessage(`Jogador renomeado para "${newName}".`, 'success');
                closeModal();
            } catch (error) {
                console.error("Erro ao renomear jogador:", error);
                showMessage("Erro ao renomear jogador. Tente novamente.", 'error');
            }
        } else if (newName === player.name) {
            closeModal(); // Apenas fecha se o nome for o mesmo
        } else {
            showMessage("O nome n√£o pode ser vazio.", 'error');
        }
    };
    document.getElementById('cancelRenamePlayerBtn').onclick = () => closeModal();
}

async function deletarJogador(playerId) {
    // 1. Verifica√ß√£o de Seguran√ßa (Admin)
    if (!appState.isAdminMode) {
        showMessage("A√ß√£o n√£o permitida. Voc√™ precisa estar em modo Admin.", 'error');
        return;
    }

    const player = appState.players[playerId];
    if (!player) return;

    // 2. Pedido de Confirma√ß√£o (Sua solicita√ß√£o)
    const confirmacao = confirm(`‚ö†Ô∏è ATEN√á√ÉO: Tem certeza que deseja excluir o jogador "${player.name}"?\n\nIsso remover√° permanentemente todos os dados, estat√≠sticas e conquistas dele de todas as temporadas. Esta a√ß√£o n√£o pode ser desfeita.`);

    if (confirmacao) {
        try {
            // 3. Refer√™ncia correta do documento no Firestore
            // O caminho segue o padr√£o do seu projeto: artifacts/ID/public/data/players
            const playerDocRef = doc(db, `artifacts/${appIdentifier}/public/data/players`, playerId);

            await deleteDoc(playerDocRef);

            // 4. Feedback e Limpeza
            closeModal();
            showMessage(`Jogador "${player.name}" removido com sucesso.`, 'success');

            // O listener do Firestore (onSnapshot) cuidar√° de atualizar a lista na tela automaticamente
        } catch (error) {
            console.error("Erro ao deletar jogador:", error);
            showMessage("Erro t√©cnico ao tentar excluir o jogador no banco de dados.", 'error');
        }
    }
}

// 5. ESSENCIAL: Torna a fun√ß√£o vis√≠vel para o 'onclick' do bot√£o no modal
window.deletarJogador = deletarJogador;

function setupFirestoreListeners() {
    // Limpa listeners antigos para evitar duplica√ß√£o
    appState.unsubscribers.forEach(unsub => unsub());
    appState.unsubscribers = [];

    // Listener para a lista de jogadores (n√£o muda)
    const unsubPlayers = onSnapshot(query(playersCollectionRef()), (snapshot) => {
        const newPlayersData = {};
        snapshot.forEach(doc => {
            const newPlayer = { id: doc.id, ...doc.data() };
            const oldPlayer = appState.players[doc.id];
            newPlayersData[doc.id] = newPlayer;
        });
        appState.players = newPlayersData;
        renderScoreboard();

        if (appState.gameState.activeGame) {
            renderLiveMatchFeed(appState.gameState.activeGame);
        }
    });

    if(document.getElementById('view-history').classList.contains('active')) {
        if(!ui.history.detailsView.classList.contains('hidden')) {
                renderActiveHistoryTab();
        } else {
            renderMatchHistoryList();
        }
    }

    // Listener para o feed de atividades gerais (n√£o muda)
    const unsubFeed = onSnapshot(query(activityFeedCollectionRef(), orderBy("timestamp", "desc"), limit(5)), (snapshot) => {
        appState.activityFeed = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderActivityFeed();
    });

    // Listener para partidas ao vivo (com verifica√ß√£o de idade)
    const q = query(matchesCollectionRef(), where("status", "==", "active"), limit(1));
    const unsubLiveMatch = onSnapshot(q, (snapshot) => {
        const header = ui.liveMatchHeader;
        const chevron = ui.liveMatchChevron;
        const headerText = header.querySelector('h2');

        const setInactiveState = () => {
            header.classList.remove('bg-green-600', 'hover:bg-green-700', 'cursor-pointer', 'animate-pulse');
            header.classList.add('bg-gray-200', 'text-gray-500', 'cursor-default');
            headerText.textContent = '‚óã NENHUMA PARTIDA ATIVA';
            chevron.classList.add('hidden');
            ui.liveMatchFeed.classList.remove('open');
            ui.liveMatchFeed.innerHTML = '';
            appState.gameState.activeGame = null;
        };

        if (snapshot.empty) {
            setInactiveState();
        } else {
            const gameData = snapshot.docs[0].data();
            const gameTimestamp = gameData.createdAt?.toDate();
            const maxAgeHours = 4; // Define que jogos com mais de 4 horas s√£o "zumbis"

            // --- IN√çCIO DA NOVA VERIFICA√á√ÉO ---
            // Se o jogo for muito antigo, trata como inativo
            if (gameTimestamp && (new Date() - gameTimestamp) / 1000 / 3600 > maxAgeHours) {
                //  console.log("Jogo ativo encontrado, mas √© muito antigo e ser√° ignorado:", gameData.id);
                setInactiveState();
            } else {
            // --- FIM DA NOVA VERIFICA√á√ÉO ---

                // Se o jogo √© recente, mostra o estado ativo
                appState.gameState.activeGame = gameData;

                header.classList.add('bg-green-600', 'hover:bg-green-700', 'cursor-pointer', 'animate-pulse');
                header.classList.remove('bg-gray-200', 'text-gray-500', 'cursor-default');
                headerText.textContent = '‚óè PARTIDA EM ANDAMENTO';
                chevron.classList.remove('hidden');

                if (Object.keys(appState.players).length > 0) {
                    renderLiveMatchFeed(gameData);
                }
            }
        }
    });

    appState.unsubscribers.push(unsubPlayers, unsubFeed, unsubLiveMatch);
}

async function checarStatusDaSerie(playerId) {
    const player = appState.players[playerId];
    if (!player) return { changed: false };

    const seriesOrder = SERIES_CONFIG.map(s => s.name);
    const currentIndex = seriesOrder.indexOf(player.series || 'Amador');

    let changes = {
        changed: false,
        undoSeries: false,
        newSeries: null,
        oldSeries: player.series,
        unlockedAchievements: [],
        promotion: false,
        demotion: false,
        stagnant: false
    };

    // Verifica√ß√£o de promo√ß√£o (15 raios na s√©rie atual)
    if ((player.raiosNaSerie || 0) >= 15 && currentIndex < seriesOrder.length - 1) {
        changes.newSeries = seriesOrder[currentIndex + 1];
        changes.changed = true;
        changes.promotion = true;

        // Verifica se √© o primeiro a chegar nesta s√©rie
        const jogadoresNaSerie = Object.values(appState.players).filter(p =>
            p.series === changes.newSeries && p.id !== playerId
        );

        if (jogadoresNaSerie.length === 0) {
            changes.unlockedAchievements.push('desbravador');
            await concederConquista(playerId, 'desbravador', `foi o primeiro a alcan√ßar a S√©rie ${changes.newSeries}! üßó‚Äç‚ôÇÔ∏è`);
        }

        if (changes.newSeries === 'A') {
            changes.unlockedAchievements.push('primeiro_rei');
        }
    }
    else if ((player.raiosNaSerie || 0) >= 15 && seriesOrder.length - 1){
        changes.stagnant = true;
        changes.changed = true;
    }
    else if ((player.raiosNaSerie || 0) === -1 && currentIndex > 0){
        const playerDocRef = doc(playersCollectionRef(), playerId);
        changes.undoSeries = true;
        changes.newSeries = seriesOrder[currentIndex - 1];
        changes.changed = true;
        changes.demotion = true;
    }
    // Verifica√ß√£o de rebaixamento (15 lambretas na s√©rie atual)
    else if ((player.lambretasNaSerie || 0) >= 15 && currentIndex > 0) {
        changes.newSeries = seriesOrder[currentIndex - 1];
        changes.changed = true;
        changes.demotion = true;
    }
    else if ((player.lambretasNaSerie || 0) >= 15 && currentIndex === 0){
        changes.stagnant = true;
        changes.changed = true;
    }

    return changes;
}

async function applySeriesChanges(playerId, changes) {
    if (!changes.changed) return;

    const playerDocRef = doc(playersCollectionRef(), playerId);
    const player = appState.players[playerId];
    let updates = {
    series: changes.stagnant ? player.series : changes.newSeries,
    raiosNaSerie: changes.stagnant ? 0 : (changes.undoSeries ? 15 : 0),
    lambretasNaSerie: changes.stagnant ? 0 : (changes.undoSeries ? player.lambretasNaSerie : 0)
    };

    await updateDoc(playerDocRef, updates);

    // Concede conquistas relacionadas a s√©ries

    if (changes.demotion){
        await concederConquista(playerId, "demotion", `foi rebaixado para S√©rie ${changes.newSeries}`);
    }
    else if (changes.promotion){
        await concederConquista(playerId, "promotion", `foi promovido para S√©rie ${changes.newSeries}`);
    }
    else if (changes.stagnant){
        await concederConquista(playerId, "stagnant", player.series === "A" ? `ganhou um raio e contioua na S√©rie  ${player.series}` : `tomou uma lambreta e permanece na S√©rie ${player.series}`);
    }
}

onAuthStateChanged(auth, async (user) => {
    if (user) {
        appState.userId = user.uid;
        setupFirestoreListeners();
        updateAdminUI(); // <--- ADICIONAR AQUI
    } else {
        try { await signInAnonymously(auth); } catch(e) { console.error("Erro no login an√¥nimo:", e); }
    }
});

function updateAdminUI() {
    const isAdmin = appState.isAdminMode;

    // Mostra/esconde o container do bot√£o "Iniciar Modo Partida"
    const goToGameContainer = document.getElementById('goToGameModeContainer');
    if (goToGameContainer) {
        goToGameContainer.classList.toggle('hidden', !isAdmin);
    }

    // Mostra/esconde o bot√£o "Nova Partida" na tela de fim de jogo
    if (ui.gameMode.newGameBtn) {
        ui.gameMode.newGameBtn.classList.toggle('hidden', !isAdmin);
    }

    // Adicione aqui qualquer outro controle de admin que precise ser mostrado/escondido no futuro.
}

// =======================================================================
//  IN√çCIO: FUN√á√ïES DE HIST√ìRICO (L√ìGICA REFORMULADA)
// =======================================================================

async function fetchMatchHistory() {
    ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Buscando hist√≥rico...</p>`;
    try {
        // const q = query(matchesCollectionRef(), where("status", "in", ["finished", "aborted"]), limit(50));
        // Adicionamos o orderBy("endedAt", "desc") ANTES do limit(50)
        const q = query(matchesCollectionRef(), where("status", "in", ["finished", "aborted"]), orderBy("endedAt", "desc"), limit(50));
        const querySnapshot = await getDocs(q);

        let matches = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        // DETETIVE 1: Mostra quantas partidas vieram do banco de dados
        // console.log("Partidas puxadas do Firebase:", matches.length, matches);

        matches.sort((a, b) => (b.endedAt?.seconds || 0) - (a.endedAt?.seconds || 0));
        appState.matchHistory = matches;

        // DETETIVE 2: Mostra como ficou a lista ap√≥s organizar por data
        // console.log("Lista organizada para exibir:", appState.matchHistory);

        renderMatchHistoryList();
    } catch (error) {
        // console.error("Erro ao buscar hist√≥rico:", error);
        ui.history.matchList.innerHTML = `<p class="text-center text-red-500 p-8">N√£o foi poss√≠vel carregar o hist√≥rico.</p>`;
    }
}

function showMatchDetails(matchId) {
    const matchData = appState.matchHistory.find(m => m.id === matchId);
    if (!matchData) return;

    // Executa a an√°lise para obter a lista real de participantes
    const { playerStats, raios } = analyzeMatchHistory(matchData);
    const listaParticipantes = Object.keys(playerStats);

    // --- LOG NO CONSOLE ---
    console.group(`üîç Detalhes da Partida: ${matchId}`);
    console.log("Todos os jogadores detectados no hist√≥rico (via scores):", listaParticipantes);
    console.table(listaParticipantes.map(id => ({
        ID: id,
        Nome: appState.players[id]?.name || "Jogador Antigo",
        Pontos: playerStats[id].pontos,
        Raios: playerStats[id].raios,
        Lambretas:playerStats[id].lambretas
    })));
    console.groupEnd();

    appState.currentMatchDetails = matchData;
    ui.history.listView.classList.add('hidden');
    ui.history.detailsView.classList.remove('hidden');

    // --- IN√çCIO DO JUIZ RETROATIVO ---
    let trueWinnerId = null;
    if (matchData.playerIds && matchData.playerIds.length > 0) {
        const gameRaios = matchData.raios || {};
        const gameScores = matchData.scores || {};

        let stats = matchData.playerIds.map(id => ({
            id: id,
            raios: Number(gameRaios[id]) || 0,
            pontos: Number(gameScores[id]) || 0
        }));

        stats.sort((a, b) => {
            if (b.raios !== a.raios) return b.raios - a.raios;
            return b.pontos - a.pontos;
        });

        const primeiro = stats[0];
        const segundo = stats[1] || { raios: -1, pontos: -1 };

        if (primeiro && (primeiro.raios > 0 || primeiro.pontos > 0)) {
            if (primeiro.raios !== segundo.raios || primeiro.pontos !== segundo.pontos) {
                trueWinnerId = primeiro.id;
            }
        }
    }
    // --- FIM DO JUIZ RETROATIVO ---

    // Define o nome do vencedor usando o resultado do juiz retroativo
    const winnerName = trueWinnerId ? (appState.players[trueWinnerId]?.name || 'Jogador Desconhecido') + ' Venceu' : 'Empate';
    const icone = trueWinnerId ? 'üèÜ' : 'ü§ù';
    const textColor = trueWinnerId ? 'text-blue-600' : 'text-gray-700';

    ui.history.detailsHeader.innerHTML = `
        <h2 class="text-3xl font-bold flex items-center justify-center gap-3 ${textColor}">
            ${icone} ${winnerName}
        </h2>
        <p class="text-gray-500 mt-2">${new Date(matchData.endedAt.seconds * 1000).toLocaleString('pt-BR', { dateStyle: 'long', timeStyle: 'short' })}</p>`;

    renderActiveHistoryTab();
}

function renderMatchHistoryList() {
    if (Object.keys(appState.players).length === 0) {
        ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Carregando dados dos jogadores...</p>`;
        return;
    }
    if (appState.matchHistory.length === 0) {
        ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Nenhuma partida encontrada.</p>`;
        return;
    }

    ui.history.matchList.innerHTML = appState.matchHistory.map(match => {

        // JUIZ RETROATIVO: Recalcula o vencedor verdadeiro ignorando o winnerInfo antigo
        let trueWinnerId = null;
        let raiosDoVencedor = 0;

        if (match.playerIds && match.playerIds.length > 0) {
            const gameRaios = match.raios || {};
            const gameScores = match.scores || {};

            // Monta a lista de jogadores daquela partida
            let stats = match.playerIds.map(id => ({
                id: id,
                raios: Number(gameRaios[id]) || 0,
                pontos: Number(gameScores[id]) || 0
            }));

            // Ordena usando a nossa regra de ouro: Raios primeiro, depois Pontos
            stats.sort((a, b) => {
                if (b.raios !== a.raios) return b.raios - a.raios;
                return b.pontos - a.pontos;
            });

            const primeiro = stats[0];
            const segundo = stats[1] || { raios: -1, pontos: -1 };

            // Verifica se o primeiro lugar realmente pontuou e n√£o est√° empatado com o segundo
            if (primeiro && (primeiro.raios > 0 || primeiro.pontos > 0)) {
                if (primeiro.raios !== segundo.raios || primeiro.pontos !== segundo.pontos) {
                    trueWinnerId = primeiro.id;
                    raiosDoVencedor = primeiro.raios;
                }
            }
        }

        // Se o juiz encontrou um vencedor, exibe ele. Se n√£o, √© um empate/aborto real.
        const winnerName = trueWinnerId ? (appState.players[trueWinnerId]?.name || 'Jogador Desconhecido') : 'Empate / Abortada';
        const date = match.endedAt?.seconds ? new Date(match.endedAt.seconds * 1000).toLocaleDateString('pt-BR') : 'Data Indefinida';

        // Define o texto detalhado para ficar bonito na lista
        const icone = trueWinnerId ? 'üèÜ' : 'ü§ù';
        const detalhe = trueWinnerId ? `${raiosDoVencedor} raios` : 'Sem vencedor isolado';

        return `
            <div onclick="showMatchDetails('${match.id}')" data-match-id="${match.id}" class="bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex items-center justify-between cursor-pointer hover:bg-blue-50 hover:border-blue-200 transition-all mb-3">
                <div class="flex items-center gap-3">
                    <div class="text-2xl">${icone}</div>
                    <div>
                        <p class="font-bold text-gray-800">${winnerName}</p>
                        <p class="text-xs font-medium text-gray-500">${date} ‚Ä¢ <span class="text-blue-600">${detalhe}</span></p>
                    </div>
                </div>
                <span class="text-gray-400 font-bold text-xl">‚Ä∫</span>
            </div>`;
    }).join('');
}

function analyzeMatchHistory(matchData) {
    const playerStats = {};
    const totalStats = { lambretas: 0, conquistas: {} };
    const raios = [];
    let currentRaioRounds = [];
    let raioNumber = 1;

    // Fun√ß√£o auxiliar para garantir que o jogador existe no objeto antes de mexer nele
    const getStats = (id) => {
        if (!id) return null;
        if (!playerStats[id]) {
            playerStats[id] = { pontos: 0, raios: 0, lambretas: 0, vitimaDeRoubo: 0, conquistas: {} };
        }
        return playerStats[id];
    };

    matchData.history.forEach((round) => {
        const pId = round.winnerId;
        const scoresObj = round.stateScore?.scores || round.scores || {};

        // 1. SEMPRE garante que todos os IDs presentes no placar deste round existem nas stats
        Object.keys(scoresObj).forEach(id => getStats(id));

        if (round.type !== 'swap' && pId) {
            const stats = getStats(pId);
            if (stats) {
                stats.pontos++;
                currentRaioRounds.push(round);

                if (round.completedRaio) {
                    stats.raios++;

                    // CAPTURA DE PARTICIPANTES: Pegamos todos os IDs que estavam no placar
                    // Isso garante que mesmo quem tem 0 pontos apare√ßa no gr√°fico
                    const participantes = new Set(Object.keys(scoresObj));
                    if (pId) participantes.add(pId);

                    raios.push({
                        raioNumber: raioNumber++,
                        winnerId: pId,
                        completionTime: round.timestamp,
                        pointSequence: currentRaioRounds.map((r, idx) => ({
                            scorerId: r.winnerId,
                            pointOrder: idx + 1
                        })),
                        participantesIds: Array.from(participantes)
                    });
                    currentRaioRounds = [];
                }
            }
        }

        // 2. Processa Lambretas (Manual/Hist√≥rico)
        if (round.lambretaPlayerIds) {
            round.lambretaPlayerIds.forEach(id => {
                const s = getStats(id);
                if (s) { s.lambretas++; totalStats.lambretas++; }
            });
        }

        // 3. Processa Roubos
        if (round.ladraoDeRaio?.vitma) {
            round.ladraoDeRaio.vitma.forEach(id => {
                const s = getStats(id);
                if (s) s.vitimaDeRoubo++;
            });
        }
    });

    return { playerStats, totalStats, raios };
}

function renderMatchStats(matchData) {
    const { playerStats, totalStats, raios } = analyzeMatchHistory(matchData);

    const totalAchievementsHTML = Object.entries(totalStats.conquistas).map(([achId, count]) => {
        const achInfo = achievements[achId];
        if (!achInfo) return '';
        return `<span class="inline-flex items-center gap-1 bg-yellow-100 text-yellow-800 text-xs font-medium px-2.5 py-0.5 rounded-full">${achInfo.icon} ${achInfo.name} ${count > 1 ? `(x${count})` : ''}</span>`;
    }).join(' ');

    const summaryBannerHTML = `
        <div class="bg-blue-50 border border-blue-200 text-blue-800 p-4 rounded-lg mb-6 text-center">
            <p class="font-semibold">Partida finalizada com <span class="font-bold">${raios.length}</span> ${raios.length === 1 ? 'raio' : 'raios'} e <span class="font-bold">${totalStats.lambretas}</span> ${totalStats.lambretas === 1 ? 'lambreta' : 'lambretas'}.</p>
            ${totalAchievementsHTML ? `<div class="flex flex-wrap justify-center gap-2 mt-2">${totalAchievementsHTML}</div>` : ''}
        </div>
    `;

    let contentHTML = summaryBannerHTML + '<div class="space-y-4">';
    // ITERAR SOBRE TODOS OS DETETADOS (Enzo, Rivelino, etc.)
    Object.keys(playerStats).forEach(id => {
        const stats = playerStats[id];

        // Opcional: n√£o mostrar jogadores que passaram pela mesa mas n√£o fizeram nada
        // if (stats.pontos === 0 && stats.raios === 0 && stats.lambretas === 0) return;

        const player = appState.players[id];
        const displayName = player ? player.name : `Jogador Antigo (${id.substring(0,5)})`;

        contentHTML += `
            <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                <p class="font-bold text-lg">${displayName}</p>
                <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 text-center">
                    <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">PONTOS</p><p class="font-bold text-lg">${stats.pontos}</p></div>
                    <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">RAIOS</p><p class="font-bold text-lg">${stats.raios}</p></div>
                    <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">LAMBRETAS</p><p class="font-bold text-lg">${stats.lambretas}</p></div>
                    <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">MATCH POINT</p><p class="font-bold text-lg">${stats.vitimaDeRoubo}</p></div>
                </div>
            </div>`;
    });

    ui.history.detailsContent.innerHTML = contentHTML + '</div>';
}

function renderMatchRaios(matchData) {
    const { raios } = analyzeMatchHistory(matchData);
    if (raios.length === 0) {
        ui.history.detailsContent.innerHTML = `<p class="text-center text-gray-500 p-8">Nenhum raio.</p>`;
        return;
    }

    let contentHTML = '<div class="space-y-4">';
    raios.forEach((raio) => {
        const winnerName = appState.players[raio.winnerId]?.name || 'Vencedor';
        let playerTracksHTML = '';

        // Iteramos sobre todos que passaram pela mesa NESTE RAIO
        raio.participantesIds.forEach(playerId => {
            const player = appState.players[playerId];
            const playerName = player ? player.name : `Jogador (${playerId.substring(0,4)})`;

            let circlesHTML = '';
            // Filtramos os pontos que ESSE jogador espec√≠fico fez neste raio
            const pointsInThisRaio = raio.pointSequence.filter(p => p.scorerId === playerId);

            // Desenha sempre 4 espa√ßos
            for (let i = 0; i < 4; i++) {
                const pt = pointsInThisRaio[i];
                if (pt) {
                    // Bolinha amarela com o n√∫mero da ordem do ponto na partida
                    circlesHTML += `<div class="point-circle rounded-full flex items-center justify-center bg-yellow-400 border-2 border-yellow-500 text-yellow-900 font-bold text-xs"><span>${pt.pointOrder}</span></div>`;
                } else {
                    // Bolinha cinza (vazia)
                    circlesHTML += `<div class="point-circle rounded-full bg-gray-200 border-2 border-gray-300"></div>`;
                }
            }

            playerTracksHTML += `
                <div class="flex items-center gap-3">
                    <p class="font-semibold w-24 truncate text-right text-sm">${playerName}</p>
                    <div class="flex items-center gap-2">${circlesHTML}</div>
                </div>`;
        });

        contentHTML += `
            <div class="bg-gray-50 rounded-lg border border-gray-200 p-4">
                <p class="font-bold text-center mb-3 text-blue-900">Raio de ${winnerName}</p>
                <div class="space-y-2">${playerTracksHTML}</div>
            </div>`;
    });
    ui.history.detailsContent.innerHTML = contentHTML + '</div>';
}

function setActiveHistoryTab(tabName) {
    ui.history.tabs.forEach(tab => tab.classList.remove('active'));
    const activeTab = document.querySelector(`.history-details-tab[data-tab="${tabName}"]`);
    if (activeTab) activeTab.classList.add('active');
}

function renderActiveHistoryTab() {
    if (!appState.currentMatchDetails) return;
    const activeTabName = document.querySelector('.history-details-tab.active')?.dataset.tab || 'stats';
    if (activeTabName === 'stats') {
        renderMatchStats(appState.currentMatchDetails);
    } else {
        renderMatchRaios(appState.currentMatchDetails);
    }
}

function showScoreboardFromHistory() {
    if (!ui.history.detailsView.classList.contains('hidden')) {
        ui.history.detailsView.classList.add('hidden');
        ui.history.listView.classList.remove('hidden');
        appState.currentMatchDetails = null;
    } else {
        switchView('view-scoreboard');
    }
}

// =======================================================================
//  FIM: FUN√á√ïES DE HIST√ìRICO
// =======================================================================

// Ativa√ß√£o do modo admin

// --- Admin Logic Atualizada ---
    ui.adminPanel.activateBtn.addEventListener('click', () => {
        const key = ui.adminPanel.keyInput.value;
        if (key === ADMIN_KEY) {
            appState.isAdminMode = true;

            // UI Feedback
            ui.adminPanel.loginView.classList.add('hidden');
            ui.adminPanel.controlsView.classList.remove('hidden');

            // ---> AQUI: Libera o bot√£o no menu <---
            ui.menu.startGame.classList.remove('hidden');

            showMessage("Modo Admin Ativado!", "success");
            renderScoreboard();
        } else {
            showMessage("Senha incorreta.", "error");
        }
    });

// Adicionar este listener para fechar quando clicar fora
// document.addEventListener('click', (e) => {
//     const isClickInsidePanel = ui.adminFab.panel.contains(e.target);
//     const isClickOnFabButton = e.target.closest('#adminFabButton');
//
//     if (ui.adminFab.panel.classList.contains('active') && !isClickInsidePanel && !isClickOnFabButton) {
//         ui.adminFab.button.classList.remove('active');
//         ui.adminFab.defaultIcon.classList.remove('hidden');
//         ui.adminFab.closeIcon.classList.add('hidden');
//         ui.adminFab.panel.classList.remove('active');
//
//         if (!appState.isAdminMode) {
//             ui.adminFab.loginView.style.display = 'block';
//             ui.adminFab.controlsView.style.display = 'none';
//             ui.adminFab.keyInput.value = '';
//         }
//     }
// });

// 4. Iniciar Partida (Novo item do menu)
    ui.menu.startGame.addEventListener('click', () => {
        ui.menu.dropdown.classList.remove('open'); // Fecha o menu
        handleStartGameClick();
    });

// function activateAdminMode() { if(ui.adminFab.keyInput.value === ADMIN_KEY) { appState.isAdminMode = true; ui.adminFab.loginView.style.display = 'none'; ui.adminFab.controlsView.style.display = 'block'; updateAdminUI(); } else { alert('Senha incorreta!'); }}


// Listener para o modo partida que estava comentado
ui.gameMode.startBtn.addEventListener('click', createGameInFirestore);

// Adicione estes novos listeners:
ui.gameMode.launchScoreBtn.addEventListener('click', launchScore);
ui.gameMode.undoBtn.addEventListener('click', undoRound);
ui.gameMode.swapPlayerBtn.addEventListener('click', iniciarTrocaDeJogador);
ui.gameMode.endBtn.addEventListener('click', () => endGame(false)); // a confirma√ß√£o √© interna
ui.gameMode.backToScoreboard_GameOverBtn.addEventListener('click', () => {
    switchView('view-scoreboard');
});

// Listener para expandir/recolher o feed da partida ao vivo
ui.liveMatchHeader.addEventListener('click', () => {
    // S√ì EXECUTA A A√á√ÉO SE HOUVER UM JOGO ATIVO NO ESTADO
    if (!appState.gameState.activeGame) {
        return;
    }
    ui.liveMatchFeed.classList.toggle('open');
    ui.liveMatchChevron.classList.toggle('open');
});

ui.gameMode.newGameBtn.addEventListener('click', () => { resetGameState(); switchView('view-game-table'); });
ui.gameMode.gameOver.gameSummaryBtn.addEventListener('click', () => showGameSummary());



// --- Admin Logic Atualizada ---
ui.adminPanel.activateBtn.addEventListener('click', () => {
    const key = ui.adminPanel.keyInput.value;
    if (key === ADMIN_KEY) {
        appState.isAdminMode = true;
        ui.adminPanel.loginView.classList.add('hidden');
        ui.adminPanel.controlsView.classList.remove('hidden');
        showMessage("Modo Admin Ativado!", "success");
        renderScoreboard();
        // activateAdminMode();
    } else {
        showMessage("Senha incorreta.", "error");
    }
});
// ui.adminFab.button.addEventListener('click', (e) => toggleAdminPanel(e));
// ui.adminFab.activateBtn.addEventListener('click', activateAdminMode);
// ui.adminFab.keyInput.addEventListener('keydown', function(event) {
//     if (event.key === 'Enter') {
//         event.preventDefault();
//         activateAdminMode();
//     }
// });

ui.adminPanel.addPlayerBtn.addEventListener('click', () => {
        ui.adminPanel.overlay.style.display = 'none'; // Fecha o painel
        addNovoJogador();
    });
// ui.notificationsBtn.addEventListener('click',async () => {
//     if ('serviceWorker' in navigator && 'Notification' in window) {
//     try {
//         const registration = await navigator.serviceWorker.register('/placar_domino/service-worker.js', {
//         scope: '/placar_domino/'
//         });
//         // console.log('SW registrado:', registration.scope);
//         requestPermissionAndGetToken(registration);
//     } catch (error) {
//         console.error('Erro ao registrar Service Worker:', error);
//     }
//     } else {
//     console.warn("SW ou Notification API n√£o suportado");
//     }
// });

ui.gameMode.goToBtn.addEventListener('click', handleStartGameClick);
ui.gameMode.backBtn.addEventListener('click', () => endGame(false));

ui.playersListDiv.addEventListener('click', e => {
    const target = e.target.closest('.player-name-clickable');
    if (target) openPlayerDetailsModal(target.dataset.playerId);
});

// SUBSTITUA O LISTENER ANTIGO DO MODAL POR ESTE
ui.modal.container.addEventListener('click', (e) => {
    const target = e.target;

    // 1. L√≥gica para fechar o modal (executada primeiro)
    if (target.id === 'modalContainer' || target.closest('#modal-close-btn') || target.closest('#modal-cancel-btn')) {
        closeModal();
        return; // Para a execu√ß√£o aqui
    }

    // 2. L√≥gica de Sele√ß√£o de Jogador (para a mesa)
    // Esta verifica√ß√£o agora acontece ANTES das de admin.
    const playerSelectBtn = target.closest('.player-select-btn');
    if (playerSelectBtn && !appState.gameState.activeGame) {
        selectPlayer(playerSelectBtn.dataset.playerId);
        return; // Para a execu√ß√£o aqui ap√≥s selecionar
    }

    // 3. L√≥gica do Admin (s√≥ √© checada se as anteriores falharem)
    if (appState.isAdminMode) {
        // Pega o ID do jogador que est√° sendo visualizado no modal de detalhes
        const playerId = appState.modalContext?.currentViewedPlayerId;

        // A√ß√µes que dependem de um jogador espec√≠fico no modal
        const statButton = target.closest('.stat-button');
        const renameButton = target.closest('#btnRenamePlayer');
        const deleteButton = target.closest('#btnDeletePlayer');

        if (statButton && playerId) {
            const { action, stat } = statButton.dataset;
            const amount = action === 'increment' ? 1 : -1;
            const valueElement = document.getElementById(`${stat}-value`);
            const currentValue = parseInt(valueElement.textContent, 10);
            const newValue = currentValue + amount;

            if (newValue >= 0) {
                valueElement.textContent = newValue;
                updatePlayerStat(playerId, stat, amount);
            } else {
                showMessage(`N√£o √© poss√≠vel ter valor negativo.`, 'error');
            }
            return;
        }

        if (renameButton && playerId) {
            renomearJogador(playerId);
            return;
        }

        if (deleteButton && playerId) {
            deletarJogador(playerId);
            return;
        }
    }
});

// For√ßar atualiza√ß√£o do Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
        try {
            const swPath = './service-worker.js'; // ou ajuste para seu caso
            const registration = await navigator.serviceWorker.register(swPath);

            // Verifica por atualiza√ß√£o imediatamente
            registration.update();

            registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (!newWorker) return;

            newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    newWorker.postMessage('SKIP_WAITING');
                    window.location.reload(); // for√ßa reload autom√°tico
                }
            });
        });

        } catch (err) {
            console.error('Erro ao registrar Service Worker:', err);
        }
    });

    // Verifica atualiza√ß√µes a cada 1h
    setInterval(() => {
        navigator.serviceWorker.getRegistration().then(reg => reg?.update());
    }, 60 * 60 * 1000);
}

</script>
</body>
</html>
