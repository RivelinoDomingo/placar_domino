    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Placar do Domin√≥ v2.0 (Integrado)</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
        <link rel="manifest" href="manifest.json" />
        <meta name="theme-color" content="#000000" />
        <link rel="icon" href="icons/icone192.png" />
        <style>
            body { font-family: 'Inter', sans-serif; background-color: #f0f2f5; }
            .font-condensed { font-family: 'Roboto Condensed', sans-serif; }
            .view { display: none; }
            .view.active { display: block; }
            .admin-fab-container { position: fixed; bottom: 2rem; right: 2rem; z-index: 1000; }
            .admin-fab { width: 60px; height: 60px; border-radius: 50%; background-color: #1f2937; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
            .admin-fab:hover { transform: scale(1.1); background-color: #374151; }
            .admin-fab.active { transform: rotate(45deg); }
            .admin-actions { position: absolute; bottom: 80px; right: 0; background-color: white; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.15); padding: 1.5rem; width: 300px; transform-origin: bottom right; transform: scale(0.9) translateY(10px); opacity: 0; visibility: hidden; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
            .admin-actions.active { transform: scale(1) translateY(0); opacity: 1; visibility: visible; }
            .achievement-icon { font-size: 1.5rem; filter: grayscale(80%); opacity: 0.4; transition: all 0.3s; }
            .achievement-icon.unlocked { filter: grayscale(0%); opacity: 1; }
            .player-name-clickable { cursor: pointer; transition: color 0.2s; }
            .player-name-clickable:hover { color: #2563eb; }
            .mesa-grid { display: grid; grid-template-columns: 1fr 2fr 1fr; grid-template-rows: 1fr 2fr 1fr; grid-template-areas: ". top ." "left middle right" ". bottom ."; aspect-ratio: 1.5 / 1; width: 100%; max-width: 800px; }
            .player-slot-top { grid-area: top; }
            .player-slot-left { grid-area: left; }
            .player-slot-right { grid-area: right; }
            .player-slot-bottom { grid-area: bottom; }
            .fade-in { animation: fadeIn 0.5s ease-in-out; }
            @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
            .point-dot { width: 10px; height: 10px; border-radius: 50%; transition: all 0.3s ease; }
            .team-legend { transition: opacity 0.3s ease-in-out; }
            /* Estilos para a anima√ß√£o do accordion */
            #liveMatchFeed {
                transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
            #liveMatchFeed.open {
                max-height: 500px; /* Um valor alto o suficiente para conter o feed */
                padding: 1rem; /* Adiciona o espa√ßamento interno quando aberto */
            }
            #liveMatchChevron.open {
                transform: rotate(180deg);
            }
            .top-player {
                background-color: #f0fdf4; /* Verde muito claro */
                border-left: 4px solid #22c55e; /* Verde */
            }
            .bottom-player {
                background-color: #fef2f2; /* Vermelho muito claro */
                border-left: 4px solid #ef4444; /* Vermelho */
            }
            /* Estilos para o Hist√≥rico */
            .history-fab { width: 60px; height: 60px; border-radius: 50%; background-color: #4f46e5; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.2); cursor: pointer; transition: all 0.3s; }
            .history-fab:hover { transform: scale(1.1); background-color: #4338ca; }
            .history-details-tab { cursor: pointer; padding: 0.75rem 1rem; border-bottom: 3px solid transparent; transition: all 0.2s; }
            .history-details-tab.active { border-bottom-color: #3b82f6; color: #2563eb; font-weight: 600; }
            .point-circle { width: 28px; height: 28px; }
            /* Impede que o fundo role quando uma classe espec√≠fica for adicionada ao body */
            body.modal-open {
                overflow: hidden;
                height: 100vh;
            }

            /* Garante que o container do modal cubra a tela e permita scroll */
            #modalContainer {
                position: fixed;
                inset: 0;
                z-index: 9999;
                overflow-y: auto; /* Permite rolar o conte√∫do do modal */
                -webkit-overflow-scrolling: touch; /* Rolagem suave no iOS */
                background-color: rgba(0, 0, 0, 0.5);
                display: none; /* Inicialmente escondido */
                overscroll-behavior: contain; /* Bloqueia a propaga√ß√£o do scroll para o fundo */
            }

            /* Ajuste no conte√∫do para n√£o ficar colado nas bordas no celular */
            #modalContent {
                margin: 1.5rem auto;
                width: 90%;
                max-width: 500px;
                position: relative;
            }
        </style>
    </head>
    <body class="text-gray-800">

    <div id="app-container" class="container mx-auto max-w-2xl p-4 sm:p-6 lg:p-8" bis_skin_checked="1">
        <div id="view-scoreboard" class="view active fade-in">

            <div class="text-center mb-8">
                <h1 class="text-4xl font-bold font-condensed tracking-wider">PLACAR DO DOMIN√ì</h1>
            </div>

            <div class="flex justify-center mb-8 hidden" id="goToGameModeContainer">
                <button id="btnGoToGameMode" class="bg-blue-600 text-white font-bold py-4 px-8 rounded-lg shadow-lg hover:bg-blue-700 transition-all duration-300 transform hover:scale-105">
                    <span class="mr-2">üÄÑ</span> Iniciar Modo Partida
                </button>
            </div>

            <div id="liveMatchContainer" class="mb-6 transition-all duration-500">

                    <div class="bg-white rounded-xl shadow-sm overflow-hidden">

                        <div id="liveMatchHeader" class="flex justify-between items-center p-4 bg-gray-200 text-gray-500 cursor-default transition">
                            <h2 class="text-lg font-bold tracking-wider">‚óã NENHUMA PARTIDA ATIVA</h2>
                            <span id="liveMatchChevron" class="transform transition-transform duration-300 hidden">‚ñº</span>
                        </div>

                        <div id="liveMatchFeed" class="overflow-hidden">
                            </div>

                    </div>
                </div>

            <div id="playersList" class="space-y-3">
                <div class="text-center text-gray-500 p-8">Carregando placar...</div>
            </div>

            <div class="mt-10">
                <h2 class="text-xl font-bold text-gray-700 mb-3">√öltimas Atividades</h2>
                <div id="activityFeed" class="space-y-2 bg-white p-4 rounded-xl shadow-sm">
                    <p class="text-gray-500 text-center">Carregando atividades...</p>
                </div>
            </div>

        </div>
        <div id="messageBox" class="message-box"></div>
        <!-- Mesa de jogo -->
        <div id="view-game-table" class="view fade-in">
            <div class="flex justify-between mb-6" bis_skin_checked="1">
                <div calss="items-start" bis_skin_checked="1">
                    <button" id="btnBackToScoreboard" bis_skin_checked="1" class="text-gray-500 hover:text-gray-800 transition">‚ÜêVoltar</button"></div>
                        <div class="flex items-center" bis_skin_checked="1">
                            <div class="text-center" bis_skin_checked="1"><h2 class="text-3xl font-bold font-condensed">MODO PARTIDA</h2><p id="gameStatusText" class="text-gray-500">Vez de teste1</p></div>
                            <div class="w-24 sm:w-56" bis_skin_checked="1"></div>
                    </div>
            </div>
            <div id="game-type-selector" class="flex justify-center gap-4 mb-4"><button data-mode="individual" class="gameModeBtn font-semibold py-2 px-4 rounded-lg shadow">Individual</button><button data-mode="duplas" class="gameModeBtn font-semibold py-2 px-4 rounded-lg">Duplas</button></div>
            <div id="raio-mode-selector" class="flex justify-center items-center gap-2 mb-6"><input type="checkbox" id="raioModeCheckbox" class="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"><label for="raioModeCheckbox" class="font-semibold text-gray-700 cursor-pointer select-none">Partida de Raio ‚ö°Ô∏è</label></div>
            <div class="bg-green-800 border-8 border-yellow-800/50 rounded-2xl shadow-2xl p-4 sm:p-8 mesa-grid mx-auto">
                <div class="flex items-center justify-center player-slot-top"><div id="slot-1" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-left"><div id="slot-4" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-right"><div id="slot-2" class="player-slot flex flex-col items-center"></div></div><div class="flex items-center justify-center player-slot-bottom"><div id="slot-3" class="player-slot flex flex-col items-center"></div></div>
            </div>
            <div class="mt-8 text-center space-y-4">
                <button id="btnStartGame" class="bg-gray-400 text-white font-bold py-3 px-6 rounded-lg shadow-md cursor-not-allowed" disabled>Iniciar Jogo</button>
                <div id="activeGameButtons" class="hidden flex-wrap justify-center gap-4"><button id="btnLaunchScore" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Lan√ßar Ponto</button><button id="btnUndoRound" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Desfazer</button><button id="btnSwapPlayer" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Trocar Jogador</button><button id="btnEndGame" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Encerrar Partida</button></div>
            </div>
        </div>
        <div id="view-game-over" class="view fade-in text-center">
            <h2 class="text-2xl text-gray-600">Fim de Jogo</h2>
            <p id="gameOverWinnerText" class="text-5xl font-bold font-condensed my-4 text-blue-600"></p>
            <p id="gameOverScoreText" class="text-xl text-gray-500 mb-8"></p>
            <div class="flex justify-center gap-4 flex-wrap">
                <button id="btnShareWhatsapp" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-green-600 transition flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg> Compartilhar</button><button id="btnGameSummary" class="bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-gray-600 transition">Ver Resumo</button><button id="btnNewGame" class="bg-blue-600 text-white hidden font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-blue-700 transition">üÄÑ Nova Partida</button><button id="btnBackToScoreboard_GameOver" class="bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg hover:bg-gray-600 transition">‚Üê Voltar ao Placar</button>
            </div>
        </div>
            <!-- NOVA TELA DE HIST√ìRICO -->
        <div id="view-history" class="view fade-in">
            <div class="flex justify-between items-center mb-6">
                <button id="btnBackToScoreboardFromHistory" class="text-gray-500 hover:text-gray-800 transition">‚Üê Voltar</button>
                <h1 class="text-3xl font-bold font-condensed">HIST√ìRICO DE PARTIDAS</h1>
                <div class="w-20"></div> <!-- Espa√ßador -->
            </div>
            <div id="history-content-container">
                <div id="history-list-view">
                    <div id="history-match-list" class="space-y-3">
                        <p class="text-center text-gray-500 p-8">Buscando hist√≥rico...</p>
                    </div>
                </div>
                <div id="history-details-view" class="hidden">
                    <div class="bg-white rounded-xl shadow-md p-4 sm:p-6">
                        <div id="history-details-header" class="text-center mb-4"></div>
                        <div class="border-b border-gray-200 flex justify-center mb-4">
                            <button data-tab="stats" class="history-details-tab active">Estat√≠sticas Gerais</button>
                            <button data-tab="raios" class="history-details-tab">An√°lise por Raio</button>
                        </div>
                        <div id="history-details-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        <div class="admin-fab-container flex flex-col items-end gap-3">

            <button id="btnRequestNotifications" title="Ativar Notifica√ß√µes" class="w-12 h-12 rounded-full bg-yellow-400 text-2xl flex items-center justify-center shadow-lg hover:bg-yellow-500 transition transform hover:scale-110">
                <span>üîî</span>
            </button>
            <button id="historyFabButton" title="Ver Hist√≥rico de Partidas" class="history-fab">
             <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M7 14l5-5 4 4 5-5"/></svg>
            </button>

            <div class="relative">
                <div id="adminActionsPanel" class="admin-actions">
                    <h3 class="font-bold text-lg mb-4 text-gray-800">Painel do Administrador</h3>
                    <div id="adminLoginView">
                        <p class="text-sm text-gray-600 mb-2">Insira a senha para gerenciar.</p>
                        <input type="password" id="adminKeyInput" placeholder="Senha de Admin" class="w-full border-gray-300 rounded-md shadow-sm p-2">
                        <button id="activateAdminBtn" class="w-full mt-3 bg-blue-600 text-white font-semibold py-2 rounded-md hover:bg-blue-700 transition">Ativar</button>
                    </div>
                    <div id="adminControlsView" class="hidden space-y-3">
                        <button id="addPlayerBtn_fab" class="w-full bg-green-500 text-white font-semibold py-2 rounded-md hover:bg-green-600 transition">Adicionar Novo Jogador</button>
                        <button id="resetScoresBtn_fab" class="w-full bg-red-600 text-white font-semibold py-2 rounded-md hover:bg-red-700 transition">Redefinir Placar Geral</button>
                        <p id="adminStatus" class="text-center text-sm text-green-600 font-semibold pt-2">Modo Admin Ativado</p>
                    </div>
                </div>
                <div id="adminFabButton" class="admin-fab">
                <svg id="fabIconDefault" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"/></svg>
                <svg id="fabIconClose" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="hidden"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </div>
            </div>
        </div>

        <div id="modalContainer" class="fixed inset-0 bg-black/60 hidden items-center justify-center p-4 z-50"><div id="modalContent" class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md m-auto"></div></div>

        <script type="module">
            import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
            import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
            import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, getDocs, orderBy, limit, serverTimestamp, writeBatch, increment, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
            import { getMessaging, getToken, onMessage } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-messaging.js";

            const firebaseConfig = {
                apiKey: "AIzaSyBqpkxcl0GkBBHVO8Nxk7UpYd00H4Frklc",
                authDomain: "placar-domino.firebaseapp.com",
                projectId: "placar-domino",
                storageBucket: "placar-domino.firebasestorage.app",
                messagingSenderId: "187178310074",
                appId: "1:187178310074:web:5f56292dea8dc776532583",
                measurementId: "G-BL3W42DJ3M"
            };

            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            const ADMIN_KEY = 'Domino25';
            const POINTS_TO_COMPLETE_RAIO = 4;
            const appIdentifier = firebaseConfig.appId;

            // --- ESTRUTURA DAS S√âRIES ---
            const SERIES_CONFIG = [
                { name: 'Amador'},
                { name: 'D'},
                { name: 'C'},
                { name: 'B'},
                { name: 'A'}
                // Voc√™ pode adicionar mais s√©ries aqui no futuro! Ex: { name: 'Lend√°rio', requiredRaios: 100 }
            ];


            const achievements = {
                primeiro_rei: { icon: 'üëë', name: 'Primeiro Rei', description: 'Chegou ao topo da S√©rie A.' },
                imbativel: { icon: 'üî•', name: 'Imbat√≠vel', description: 'Venceu 3 raios seguidos.' },
                desbravador: { icon: 'üßó‚Äç‚ôÇÔ∏è', name: 'Desbravador', description: 'Primeiro a chegar a uma nova s√©rie.'},
                azarao: { icon: 'üöë', name: 'Azar√£o', description: 'Sofreu 3 lambretas seguidas.' },
                roubo: { icon: 'üëÆüèªüöî', name: 'Ladr√£o', description: 'Ladr√£o de raio' }
            };

            // let appState = { players: {}, finalGameData: {}, activityFeed: [], isAdminMode: false, userId: null, gameState: {}, unsubscribers: [] };
            let appState = { players: {}, finalGameData: {}, activityFeed: [], isAdminMode: false, userId: null, gameState: {}, unsubscribers: [], messageQueue: [], isMessageShowing: false, matchHistory: [], currentMatchDetails: null };

            const playersCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/players`);
            const activityFeedCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/events`);
            const matchesCollectionRef = () => collection(db, `artifacts/${appIdentifier}/public/data/partidas`);

            function getCurrentSeasonNumber() {
                const firstSeasonStart = new Date("2025-07-06T00:00:00Z"); // voc√™ pode mudar essa data
                const now = new Date();
                const daysSinceStart = Math.floor((now - firstSeasonStart) / (1000 * 60 * 60 * 24));
                return Math.floor(daysSinceStart / 30);
            }
            const currentSeason = `temporada_${getCurrentSeasonNumber()}`;

            const ui = {
                views: document.querySelectorAll('.view'),
                messageBox: document.getElementById('messageBox'),
                notificationsBtn: document.getElementById('btnRequestNotifications'),
                playersListDiv: document.getElementById('playersList'),
                activityFeedDiv: document.getElementById('activityFeed'),
                liveMatchContainer: document.getElementById('liveMatchContainer'),
                liveMatchHeader: document.getElementById('liveMatchHeader'),
                liveMatchFeed: document.getElementById('liveMatchFeed'),
                liveMatchChevron: document.getElementById('liveMatchChevron'),
                history: { fabButton: document.getElementById('historyFabButton'),
                backButton: document.getElementById('btnBackToScoreboardFromHistory'),
                listView: document.getElementById('history-list-view'),
                detailsView: document.getElementById('history-details-view'),
                matchList: document.getElementById('history-match-list'),
                detailsHeader: document.getElementById('history-details-header'),
                detailsContent: document.getElementById('history-details-content'),
                tabs: document.querySelectorAll('.history-details-tab')},
                adminFab: { button: document.getElementById('adminFabButton'), panel: document.getElementById('adminActionsPanel'), defaultIcon: document.getElementById('fabIconDefault'), closeIcon: document.getElementById('fabIconClose'), loginView: document.getElementById('adminLoginView'), controlsView: document.getElementById('adminControlsView'), keyInput: document.getElementById('adminKeyInput'), activateBtn: document.getElementById('activateAdminBtn'), addPlayerBtn: document.getElementById('addPlayerBtn_fab'), resetBtn: document.getElementById('resetScoresBtn_fab')},
                modal: { container: document.getElementById('modalContainer'), content: document.getElementById('modalContent')},
                gameMode: { goToBtn: document.getElementById('btnGoToGameMode'), backBtn: document.getElementById('btnBackToScoreboard'), modeButtons: document.querySelectorAll('.gameModeBtn'), raioCheckbox: document.getElementById('raioModeCheckbox'), startBtn: document.getElementById('btnStartGame'), activeButtons: document.getElementById('activeGameButtons'), launchScoreBtn: document.getElementById('btnLaunchScore'), undoBtn: document.getElementById('btnUndoRound'), swapPlayerBtn: document.getElementById('btnSwapPlayer'), endBtn: document.getElementById('btnEndGame'), newGameBtn: document.getElementById('btnNewGame'), shareBtn: document.getElementById('btnShareWhatsapp'), backToScoreboard_GameOverBtn: document.getElementById('btnBackToScoreboard_GameOver'), statusText: document.getElementById('gameStatusText'), gameOver: { winnerText: document.getElementById('gameOverWinnerText'), gameSummaryBtn: document.getElementById('btnGameSummary'), scoreText: document.getElementById('gameOverScoreText')}}
            };

            async function requestPermissionAndGetToken(swRegistration) {
                try {
                    const permission = await Notification.requestPermission();
                    if (permission !== "granted") {
                        showMessage("Permiss√£o negada para notifica√ß√µes.", "info");
                        return;
                    }

                    const messaging = getMessaging(app);

                    // Chamada √∫nica e correta usando o par√¢metro swRegistration
                    const currentToken = await getToken(messaging, {
                        vapidKey: "BJdf45m2Tewt6PAawR7dbwpIwhP_iEsA4wirxSSOxd6dqhj1tGAJe_zTo3CznlFeTeHLdvOTYi6XjOdnbaYcqQw",
                        serviceWorkerRegistration: swRegistration
                    });

                    if (currentToken) {
                        // Salva no Firestore
                        const tokensRef = collection(db, `artifacts/${appIdentifier}/public/data/subscriptions`);
                        await setDoc(doc(tokensRef, currentToken), {
                            timestamp: serverTimestamp(),
                            browser: navigator.userAgent // √ötil para debug
                        });

                        console.log("Novo token gerado e salvo:", currentToken);
                        showMessage("Notifica√ß√µes ativadas!", "success");
                    } else {
                        showMessage("Token n√£o p√¥de ser obtido.", "error");
                    }
                } catch (error) {
                    console.error("Erro ao obter permiss√£o ou token:", error);
                    showMessage("Erro ao ativar notifica√ß√µes.", "error");
                }
            }

            // --- BLOCO DE FUN√á√ïES DE IN√çCIO DE JOGO (VERS√ÉO CORRIGIDA) ---

            // FUN√á√ÉO 1: Chamada pelo bot√£o "Iniciar Modo Partida" no placar.
            // Ela √© a "telefonista" que decide o que fazer.
            async function handleStartGameClick() {
                if (!appState.isAdminMode) {
                    showMessage("Apenas administradores podem iniciar uma partida.", "error");
                    return;
                }

                const q = query(matchesCollectionRef(), where("status", "==", "active"));
                const activeGameSnapshot = await getDocs(q);

                if (activeGameSnapshot.empty) {
                    // Se n√£o h√° jogo ativo, apenas limpa o estado e vai para a tela de prepara√ß√£o.
                    resetGameState();
                    switchView('view-game-table');
                } else {
                    // Se encontrou um jogo ativo, pergunta ao usu√°rio o que fazer.
                    const gameDoc = activeGameSnapshot.docs[0];
                    promptResumeGame(gameDoc.id, gameDoc.data());
                }
            }

            function setupActiveGameUI() {
                // Esconde os controles de pr√©-jogo
                ui.gameMode.startBtn.style.display = 'none';
                document.getElementById('game-type-selector').style.display = 'none';
                document.getElementById('raio-mode-selector').style.display = 'none';

                // Mostra os bot√µes de a√ß√£o da partida
                ui.gameMode.activeButtons.style.display = 'flex';
            }

            // FUN√á√ÉO 2: Chamada pelo bot√£o "Iniciar Jogo" na mesa, ap√≥s selecionar os jogadores.
            // Ela efetivamente cria a partida no Firestore.
            async function createGameInFirestore() {
                ui.gameMode.startBtn.disabled = true;
                try {
                    // Limpeza de jogos "zumbis" continua aqui, como uma seguran√ßa extra.
                    const q = query(matchesCollectionRef(), where("status", "==", "active"));
                    const oldGames = await getDocs(q);
                    if (!oldGames.empty) {
                        const batch = writeBatch(db);
                        oldGames.forEach(doc => batch.update(doc.ref, { status: 'aborted', endedAt: serverTimestamp() }));
                        await batch.commit();
                    }

                    const { gameMode, isRaioMatch, selectedSlots } = appState.gameState;
                    const playerIds = Object.values(selectedSlots).filter(Boolean);

                    const requiredPlayers = gameMode === 'duplas' ? 4 : 2;
                    if(playerIds.length < requiredPlayers) {
                        showMessage(`S√£o necess√°rios pelo menos ${requiredPlayers} jogadores para este modo.`, "error");
                        ui.gameMode.startBtn.disabled = false;
                        return;
                    }

                    let gameData = {
                        gameMode, isRaioMatch, selectedSlots, playerIds, status: 'active',
                        history: [], createdAt: serverTimestamp(),
                        scores: playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {}),
                        raios: playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {})
                    };

                    const gameDocRef = await addDoc(matchesCollectionRef(), gameData);
                    appState.gameState.activeGameId = gameDocRef.id;

                    const unsub = onSnapshot(gameDocRef, (doc) => {
                        if (doc.exists()) renderActiveGame(doc.data());
                    });
                    appState.gameState.activeGameListener = unsub;
                    appState.unsubscribers.push(unsub);

                    setupActiveGameUI();
                    showMessage("Nova partida iniciada!", "success");
                } catch (error) {
                    console.error("Erro ao criar partida:", error);
                    showMessage("N√£o foi poss√≠vel criar a partida.", "error");
                    ui.gameMode.startBtn.disabled = false;
                }
            }

            // FUN√á√ÉO 3: Abre o modal de decis√£o (n√£o muda)
            function promptResumeGame(gameId, gameData) {
                const playerNames = gameData.playerIds.map(id => appState.players[id]?.name || '?').join(', ');
                const modalHTML = `
                    <h3 class="text-xl font-bold">Partida Ativa Encontrada</h3>
                    <p class="my-4 text-gray-700">J√° existe uma partida em andamento com: <strong class="font-semibold">${playerNames}</strong>.</p>
                    <p class="text-gray-700">O que voc√™ deseja fazer?</p>
                    <div class="flex flex-col sm:flex-row justify-end gap-3 mt-6">
                        <button id="btnDiscardAndNew" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition">Descartar e Iniciar Nova</button>
                        <button id="btnResume" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Continuar Partida</button>
                    </div>`;
                openModal(modalHTML);
                document.getElementById('btnResume').onclick = () => resumeGame(gameId, gameData);
                document.getElementById('btnDiscardAndNew').onclick = async () => {
                    closeModal();
                    await updateDoc(doc(matchesCollectionRef(), gameId), { status: 'aborted', endedAt: serverTimestamp() });
                    resetGameState();
                    switchView('view-game-table');
                    showMessage("Partida anterior descartada.", "info");
                };
            }

            // FUN√á√ÉO 4: L√≥gica para continuar um jogo existente (n√£o muda)
            function resumeGame(gameId, gameData) {
                closeModal();
                if (appState.gameState.activeGameListener) appState.gameState.activeGameListener();

                appState.gameState.activeGameId = gameId;
                appState.gameState.activeGame = gameData;
                appState.gameState.selectedSlots = gameData.selectedSlots;

                const gameDocRef = doc(matchesCollectionRef(), gameId);
                const unsub = onSnapshot(gameDocRef, (doc) => { if (doc.exists()) renderActiveGame(doc.data()); });
                appState.gameState.activeGameListener = unsub;
                appState.unsubscribers.push(unsub);

                switchView('view-game-table');
                renderAllSlots();
                setupActiveGameUI();
                showMessage("Partida recuperada com sucesso!", "success");
            }

            function generateScoreHTML(raiosDaPartida, pontosAtuais, isRaioMatch) {
                // Mostra os raios Ganhos APENAS nesta partida.
                // Gera o contador de raios
                const raioCounterHTML = raiosDaPartida > 1 ? `
                    <span class="ml-1 text-sm font-bold text-yellow-700">(x${raiosDaPartida})</span>
                ` : '';

                const raiosHTML = raiosDaPartida > 0 ? `
                    <div class="flex items-center justify-center text-2xl mt-2">
                        <span>‚ö°Ô∏è</span>
                        ${raioCounterHTML}
                    </div>
                ` : '<div class="h-9"></div>'; // Espa√ßo reservado para manter a altura
                // const raiosHTML = Array.from({ length: raiosDaPartida }, () => `<span class="text-2xl" title="Raio da Partida">‚ö°Ô∏è</span>`).join('');

                let pontosHTML = '';
                if (isRaioMatch) {
                    pontosHTML = Array.from({ length: pontosAtuais }, () => `<span class="text-xl" title="Ponto de Raio">‚ö°Ô∏è</span>`).join('');
                } else {
                    pontosHTML = Array.from({ length: pontosAtuais }, () => `<div class="point-dot bg-yellow-400" title="Ponto"></div>`).join('');
                }

                let renderRaiosAndPoints = `
                <div class="flex flex-col items-center my-2">  <!-- flex-col para empilhar verticalmente -->
                    ${raiosHTML}
                    <div class="flex justify-center gap-1.5 mt-1"> <!-- Container para os pontos -->
                        ${pontosHTML}
                    </div>
                </div>
                `;

                return renderRaiosAndPoints;
            }

            function renderActiveGame(gameData) {
                // 1. Atualiza o estado local primeiro (crucial para tudo funcionar)
                appState.gameState.activeGame = gameData;

                // 2. Lida com os estados de fim de jogo
                if (gameData.status === 'finished') {
                    processAndShowGameOver(gameData);
                    return;
                }
                if (gameData.status === 'aborted') {
                    resetGameState();
                    switchView('view-scoreboard');
                    return;
                }

                // 3. Atualiza o texto de status (Vez de...)
                const { turn } = gameData;
                const turnPlayerName = appState.players[turn]?.name || '';
                ui.gameMode.statusText.textContent = `Vez de ${turnPlayerName}`;

                // 4. Comanda uma renderiza√ß√£o completa da mesa.
                // Esta √∫nica linha garante que os nomes e placares sejam sempre atualizados.
                renderAllSlots();

                // 5. Atualiza o estado do bot√£o "Desfazer".
                ui.gameMode.undoBtn.disabled = gameData.history.length === 0;
            }

            async function promptLambretaManual(loserIds, winnerName) {
                // Esta fun√ß√£o usa uma 'Promise' para esperar a sele√ß√£o do usu√°rio
                return new Promise((resolve) => {
                    // Monta o HTML do modal com checkboxes para cada perdedor
                    let modalHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-bold">Registrar Lambretas</h3>
                            <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
                        </div>
                        <p class="text-sm text-gray-600 my-2">Rodada vencida por <span class="font-semibold">${winnerName}</span>. Selecione os perdedores que n√£o marcaram pontos:</p>
                        <div class="space-y-2 mt-4">
                    `;

                    loserIds.forEach(id => {
                        const player = appState.players[id];
                        if (player) {
                            modalHTML += `
                                <label for="lambreta-${id}" class="flex items-center p-3 bg-gray-50 rounded-lg cursor-pointer hover:bg-gray-100 transition-all duration-200 border-2 border-transparent has-[:checked]:border-blue-500 has-[:checked]:bg-blue-50">
                                    <input type="checkbox" id="lambreta-${id}" value="${id}" class="h-5 w-5 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                    <span class="ml-3 font-medium">${player.name}</span>
                                </label>
                            `;
                        }
                    });

                    modalHTML += `</div><button id="confirmLambretas" class="mt-6 w-full bg-blue-600 text-white font-semibold py-2 rounded-lg hover:bg-blue-700 transition">Confirmar Lambretas</button>`;

                    openModal(modalHTML);

                    // Fun√ß√£o para resolver e fechar
                    const resolverSelecao = () => {
                        const playersComLambreta = [];
                        loserIds.forEach(id => {
                            const checkbox = document.getElementById(`lambreta-${id}`);
                            if (checkbox && checkbox.checked) {
                                playersComLambreta.push(id);
                            }
                        });
                        closeModal();
                        resolve(playersComLambreta); // Retorna a lista de IDs selecionados
                    };

                    // Adiciona os listeners para os bot√µes do modal
                    document.getElementById('confirmLambretas').onclick = resolverSelecao;

                    // Se o usu√°rio fechar no 'X', retorna uma lista vazia
                    const closeBtn = document.getElementById('modal-close-btn');
                    if(closeBtn) {
                        closeBtn.onclick = () => {
                            closeModal();
                            resolve([]);
                        };
                    }
                });
            }

            async function launchScore() {
                if (!appState.gameState.activeGame) {
                    showMessage("Aguarde, o jogo est√° sincronizando...", "error");
                    return;
                }

                const { playerIds } = appState.gameState.activeGame;
                // Removido isRaioMatch. A vit√≥ria agora √© sempre com 4 pontos.
                const WINNING_SCORE = 4;

                // 1. Cria√ß√£o do modal de sele√ß√£o do vencedor (Apenas Individual)
                let modalHTML = `<h3 class="text-2xl font-bold mb-4">Quem venceu a rodada?</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;

                const players = playerIds.map(id => appState.players[id]);
                modalHTML += playerIds.map(id => {
                    const p = appState.players[id];
                    return p ? `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition winner-select-btn" data-player-id="${id}">${p.name}</button>` : '';
                }).join('');

                modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;
                openModal(modalHTML);

                // 2. L√≥gica de sele√ß√£o do vencedor
                ui.modal.content.onclick = async (e) => {
                    const target = e.target.closest('.winner-select-btn');
                    if (!target) return;

                    const winnerIdFromButton = target.dataset.playerId;
                    const winnerNameFromButton = target.innerText;

                    console.log("CLIQUE DETECTADO:");
                    console.log("Nome no Bot√£o:", winnerNameFromButton);
                    console.log("ID no dataset:", winnerIdFromButton);
                    console.log("Nome esperado no Cache:", appState.players[winnerIdFromButton]?.name);

                    closeModal();
                    const batch = writeBatch(db);
                    const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
                    const currentGame = appState.gameState.activeGame;

                    // winnerId capturado diretamente do bot√£o clicado
                    const winnerId = target.dataset.playerId;
                    const winnerPlayerDocRef = doc(playersCollectionRef(), winnerId);
                    const newScore = (currentGame.scores[winnerId] || 0) + 1;

                    const playerUpdates = {};
                    const unlockedAchievements = {};
                    let matchUpdates = {};
                    let completedRaio = false;
                    let lambretaLosersThisRound = [];
                    let matchPointsThisRound = [];
                    let stateScore = {};
                    let ladraoDeRaio = { vitma: [], ladrao: [] };
                    const loserIds = currentGame.playerIds.filter(id => id !== winnerId);

                    // Atualiza√ß√£o de pontos na temporada
                    playerUpdates[`${currentSeason}.pontosNaTemporada`] = increment(1);
                    playerUpdates.pontos = increment(1);

                    // L√≥gica de ladr√£o de raio (quando algu√©m est√° com 3 e o outro pontua)
                    if (newScore >= 3) {
                        let ladraoIsTrue = false;
                        for (const jogador of loserIds) {
                            if (currentGame.scores[jogador] === 0) {
                                ladraoDeRaio.ladrao.push(jogador);
                                if (!ladraoIsTrue) {
                                    ladraoDeRaio.vitma.push(winnerId);
                                    ladraoIsTrue = true;
                                }
                            }
                        }
                    }

                    if (newScore === 3) {
                        playerUpdates[`${currentSeason}.matchPointsNaTemporada`] = increment(1);
                        matchPointsThisRound.push(winnerId);
                    }

                    const jogadorRaiosLambretas = {};

                    if (newScore >= WINNING_SCORE) {
                        completedRaio = true;
                        playerUpdates.raios = increment(1);
                        playerUpdates.partidasJogadas = increment(1);
                        playerUpdates[`${currentSeason}.raiosNaTemporada`] = increment(1);
                        playerUpdates[`${currentSeason}.partidasNaTemporada`] = increment(1);

                        // Atualiza partidas jogadas dos perdedores
                        for (const loserId of loserIds) {
                            batch.update(doc(playersCollectionRef(), loserId), {
                                [`${currentSeason}.partidasNaTemporada`]: increment(1),
                                partidasJogadas: increment(1)
                            });
                        }

                        // L√≥gica de lambretas
                        stateScore = { ...currentGame.scores, [winnerId]: newScore };

                        for (const loserId of loserIds) {
                            if ((stateScore[loserId] || 0) === 0) {
                                batch.update(doc(playersCollectionRef(), loserId), {
                                    lambreta: increment(1),
                                    [`${currentSeason}.lambretasNaTemporada`]: increment(1)
                                });
                                lambretaLosersThisRound.push(loserId);
                            }
                        }

                        // L√≥gica de conquista Roubo de Raio
                        const ultimoRaioIndex = currentGame.history.findLastIndex(r => r.completedRaio);
                        const rodadasRelevantes = ultimoRaioIndex !== -1 ? currentGame.history.slice(ultimoRaioIndex + 1) : currentGame.history.slice();

                        const vitimas = [];
                        const ladroes = [];

                        rodadasRelevantes.forEach(round => {
                            if (round.ladraoDeRaio?.vitma?.length) {
                                vitimas.push(...round.ladraoDeRaio.vitma);
                                ladroes.push(...round.ladraoDeRaio.ladrao);
                            }
                        });

                        const vitimasUnicas = [...new Set(vitimas)];
                        const ladroesUnicos = [...new Set(ladroes)];

                        if (ladroesUnicos.includes(winnerId)) {
                            const vitimaId = vitimasUnicas.find(vId =>
                                rodadasRelevantes.some(r =>
                                    r.ladraoDeRaio?.ladrao?.includes(winnerId) &&
                                    r.ladraoDeRaio.vitma?.includes(vId)
                                )
                            );

                            if (vitimaId) {
                                showMessage(`${appState.players[winnerId]?.name} ROUBOU o raio de ${appState.players[vitimaId]?.name}! üïµÔ∏è‚Äç‚ôÇÔ∏è‚ö°`, 'warning');
                                await concederConquista(winnerId, 'roubo', `üöîüëÆüèªChama a policia que ${appState.players[winnerId]?.name} acabou de roubar o raio de ${appState.players[vitimaId]?.name}`);
                                if (!unlockedAchievements[winnerId]) unlockedAchievements[winnerId] = [];
                                unlockedAchievements[winnerId].push('roubo');
                            }
                        }

                        // Feedback visual do raio
                        showMessage(`${appState.players[winnerId].name} ganhou um Raio! ‚ö°Ô∏è`, 'success');

                        // Backup para desfazer a√ß√£o se necess√°rio
                        jogadorRaiosLambretas[winnerId] = {
                            raiosNaTemporada: appState.players[winnerId][currentSeason]?.raiosNaTemporada || 0,
                            lambretasNaTemporada: appState.players[winnerId][currentSeason]?.lambretasNaTemporada || 0,
                            series: appState.players[winnerId].series || 0
                        };

                        for (const loserId of lambretaLosersThisRound) {
                            showMessage(`${appState.players[loserId].name} tomou uma lambreta! üöë`, 'info');
                            jogadorRaiosLambretas[loserId] = {
                                raiosNaTemporada: appState.players[loserId][currentSeason]?.raiosNaTemporada || 0,
                                lambretasNaTemporada: appState.players[loserId][currentSeason]?.lambretasNaTemporada || 0,
                                series: appState.players[loserId].series || 0
                            };
                        }

                        // L√≥gica Conquista Imbat√≠vel (3 raios seguidos)
                        const historicoDeRaios = currentGame.history.filter(r => r.completedRaio);
                        if (historicoDeRaios.length >= 3) { // 2 anteriores + o atual = 3
                            let vitoriasConsecutivas = 0;
                            for (let i = historicoDeRaios.length - 1; i >= 0; i--) {
                                if (historicoDeRaios[i].winnerId === winnerId) vitoriasConsecutivas++;
                                else break;
                            }
                            if (vitoriasConsecutivas > 0 && vitoriasConsecutivas % 3 === 0) {
                                await concederConquista(winnerId, 'imbativel', `alcan√ßou uma sequ√™ncia de ${vitoriasConsecutivas} raios! üî•üöÄüöÄ`);
                                if (!unlockedAchievements[winnerId]) unlockedAchievements[winnerId] = [];
                                unlockedAchievements[winnerId].push('imbativel');
                            }
                        }

                        // L√≥gica Conquista Azar√£o (3 lambretas seguidas)
                        for (const jogadorId of playerIds) {
                            let derrotasConsecutivas = (lambretaLosersThisRound.includes(jogadorId)) ? 1 : 0;
                            if (derrotasConsecutivas === 0) continue;

                            for (let i = historicoDeRaios.length - 1; i >= 0; i--) {
                                const round = historicoDeRaios[i];
                                if (round.lambretaPlayerIds?.includes(jogadorId)) {
                                    derrotasConsecutivas++;
                                } else {
                                    break;
                                }
                            }
                            if (derrotasConsecutivas > 0 && derrotasConsecutivas % 3 === 0) {
                                await concederConquista(jogadorId, 'azarao', `sofreu uma sequ√™ncia de ${derrotasConsecutivas} lambretas! üöëü§ïü§ï`);
                                if (!unlockedAchievements[jogadorId]) unlockedAchievements[jogadorId] = [];
                                unlockedAchievements[jogadorId].push('azarao');
                            }
                        }
                    }

                    // Constru√ß√£o do roundEvent
                    matchUpdates.scores = { ...currentGame.scores, [winnerId]: newScore };
                    matchUpdates.raios = currentGame.raios;
                    matchUpdates.turn = winnerId;

                    batch.update(winnerPlayerDocRef, playerUpdates);

                    const roundEvent = {
                        roundNumber: currentGame.history.length + 1,
                        winnerId: winnerId,
                        completedRaio: completedRaio,
                        unlockedAchievements: unlockedAchievements,
                        preUpdateStats: jogadorRaiosLambretas,
                        timestamp: new Date()
                    };

                    if (lambretaLosersThisRound.length > 0) roundEvent.lambretaPlayerIds = lambretaLosersThisRound;
                    if (matchPointsThisRound.length > 0) roundEvent.matchPointPlayerIds = matchPointsThisRound;

                    if (completedRaio) {
                        roundEvent.stateScore = {
                            scores: currentGame.playerIds.reduce((acc, id) => ({ ...acc, [id]: 0 }), {}),
                            raios: {
                                ...currentGame.raios,
                                [winnerId]: (currentGame.raios[winnerId] || 0) + 1
                            }
                        };
                    } else {
                        roundEvent.stateScore = {
                            scores: matchUpdates.scores,
                            raios: matchUpdates.raios
                        };
                    }

                    if (ladraoDeRaio.vitma.length > 0) {
                        roundEvent.ladraoDeRaio = ladraoDeRaio;
                    }

                    const newHistory = [...currentGame.history, roundEvent];

                    // 1. Executa as atualiza√ß√µes das estat√≠sticas dos jogadores
                    await batch.commit();

                    if (completedRaio) {
                        await atualizarAproveitamentoTemporada(winnerId);
                        for (const loserId of loserIds) {
                            await atualizarAproveitamentoTemporada(loserId);
                        }
                    }

                    // 2. Atualiza o objeto da partida no banco
                    matchUpdates.raios = roundEvent.stateScore.raios;
                    matchUpdates.scores = roundEvent.stateScore.scores;
                    matchUpdates.turn = winnerId;

                    await updateDoc(gameDocRef, { ...matchUpdates, history: newHistory });
                };
            }

            async function undoRound() {
                const currentGame = appState.gameState.activeGame;
                if (!currentGame || currentGame.history.length === 0) return;

                const batch = writeBatch(db);
                const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
                const lastRound = currentGame.history[currentGame.history.length - 1];

                for (const playerId in lastRound.preUpdateStats){
                    batch.update(doc(playersCollectionRef(), playerId), {
                        [`${currentSeason}.raiosNaTemporada`]: lastRound.preUpdateStats[playerId].raiosNaTemporada,
                        [`${currentSeason}.lambretasNaTemporada`]: lastRound.preUpdateStats[playerId].lambretasNaTemporada,
                        series: lastRound.preUpdateStats[playerId].series
                    });
                }

                // 1. Reverte estat√≠sticas b√°sicas
                batch.update(doc(playersCollectionRef(), lastRound.winnerId), {
                    pontos: increment(-1),
                    [`${currentSeason}.pontosNaTemporada`]: increment(-1)
                });
                // Reverte MatchPoints
                if (lastRound.matchPointPlayerIds?.length > 0){
                    lastRound.matchPointPlayerIds.forEach(id => {
                        batch.update(doc(playersCollectionRef(), id), {
                            [`${currentSeason}.matchPointsNaTemporada`]: increment(-1),
                        });
                    });
                }

                if (lastRound.completedRaio) {
                    batch.update(doc(playersCollectionRef(), lastRound.winnerId), {
                        raios: increment(-1),
                        partidasJogadas: increment(-1),
                        [`${currentSeason}.partidasNaTemporada`]: increment(-1)
                    });

                    // Reverte partidas jogadas dos outros jogadores
                    currentGame.playerIds.filter(id => id !== lastRound.winnerId).forEach(id => {
                        batch.update(doc(playersCollectionRef(), id), {
                            partidasJogadas: increment(-1),
                            [`${currentSeason}.partidasNaTemporada`]: increment(-1)
                        });
                    });

                    // Reverte lambretas
                    if (lastRound.lambretaPlayerIds?.length > 0) {
                        lastRound.lambretaPlayerIds.forEach(id => {
                            batch.update(doc(playersCollectionRef(), id), {
                                lambreta: increment(-1),
                            });
                        });
                    }
                }

                // 2. Reverte conquistas
                if (lastRound.unlockedAchievements) {
                    for (const [playerId, achievements] of Object.entries(lastRound.unlockedAchievements)) {
                        const playerRef = doc(playersCollectionRef(), playerId);
                        achievements.forEach(ach => {
                            batch.update(playerRef, {
                                [`conquistas.${ach}`]: increment(-1),
                                [`${currentSeason}.conquistasNaTemporada.${ach}`]: increment(-1)
                            });

                        });
                    }
                }

                // 4. Restaura estado anterior do jogo
                const previousState = currentGame.history.length > 1 ?
                    currentGame.history[currentGame.history.length - 2].stateScore : {
                        scores: Object.fromEntries(currentGame.playerIds.map(id => [id, 0])),
                        raios: Object.fromEntries(currentGame.playerIds.map(id => [id, 0]))
                    };

                await batch.commit();

                // 5. Atualiza o documento do jogo
                await updateDoc(gameDocRef, {
                    scores: previousState.scores,
                    raios: previousState.raios,
                    turn: lastRound.winnerId,
                    history: currentGame.history.slice(0, -1)
                });

                showMessage("Rodada desfeita com todas as consequ√™ncias revertidas", "success");
            }

            function iniciarTrocaDeJogador() {
                if (!appState.isAdminMode || !appState.gameState.activeGame) return;

                const currentGame = appState.gameState.activeGame;
                const currentPlayers = currentGame.playerIds.map(id => appState.players[id]);

                let modalHTML = `<h3 class="text-2xl font-bold mb-4">Quem ser√° substitu√≠do?</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;
                currentPlayers.forEach(p => {
                    if (p) {
                        modalHTML += `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition" data-player-id-out="${p.id}">${p.name}</button>`;
                    }
                });
                modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;
                openModal(modalHTML);

                ui.modal.content.onclick = (e) => {
                    const playerOutBtn = e.target.closest('[data-player-id-out]');
                    if (playerOutBtn) {
                        const playerOutId = playerOutBtn.dataset.playerIdOut;
                        // N√£o passa mais o 'currentGame'
                        promptNovoJogadorParaTroca(playerOutId);
                    }
                };
            }

            function promptNovoJogadorParaTroca(playerOutId) {
                const availablePlayers = Object.values(appState.players).filter(p => !appState.gameState.activeGame.playerIds.includes(p.id));

                if (availablePlayers.length === 0) {
                    showMessage("N√£o h√° jogadores dispon√≠veis para a troca.", "error");
                    return;
                }

                let modalHTML = `<h3 class="text-2xl font-bold mb-4">Selecione o Substituto</h3><div class="space-y-2 max-h-64 overflow-y-auto">`;
                availablePlayers.forEach(p => {
                    modalHTML += `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition" data-player-id-in="${p.id}">${p.name}</button>`;
                });
                modalHTML += `</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;

                openModal(modalHTML);

                ui.modal.content.onclick = async (e) => {
                    const playerInBtn = e.target.closest('[data-player-id-in]');
                    if (playerInBtn) {
                        const playerInId = playerInBtn.dataset.playerIdIn;
                        // N√£o passa mais o 'currentGame'
                        await executarTrocaNoBD(playerOutId, playerInId);
                    }
                };
            }

            async function executarTrocaNoBD(oldPlayerId, newPlayerId) {
                closeModal();
                showMessage("Processando troca...", "info");

                const gameId = appState.gameState.activeGameId;
                if (!gameId) return;

                const gameDocRef = doc(matchesCollectionRef(), gameId);

                try {
                    const gameDocSnapshot = await getDoc(gameDocRef);
                    if (!gameDocSnapshot.exists()) return;
                    const currentGame = gameDocSnapshot.data();

                    // 1. Localiza qual slot (posi√ß√£o na mesa) o jogador antigo ocupava
                    const slotToUpdate = Object.keys(currentGame.selectedSlots).find(key => currentGame.selectedSlots[key] === oldPlayerId);
                    if (!slotToUpdate) return;

                    // 2. Atualiza os slots ativos e a lista de IDs na mesa
                    const newSelectedSlots = { ...currentGame.selectedSlots, [slotToUpdate]: newPlayerId };
                    const newPlayerIds = Object.values(newSelectedSlots);

                    // 3. Gerencia Scores e Raios
                    // Mantemos os pontos do jogador antigo no objeto para o hist√≥rico n√£o quebrar,
                    // e inicializamos o novo jogador com 0.
                    const newScores = { ...(currentGame.scores || {}) };
                    newScores[newPlayerId] = 0;
                    // Nota: N√ÉO deletamos o oldPlayerId daqui, para que os pontos dele continuem registrados na partida.

                    const newRaios = { ...(currentGame.raios || {}) };
                    newRaios[newPlayerId] = 0;

                    // 4. HIST√ìRICO: N√ÉO alteramos os rounds passados!
                    // Apenas criamos uma c√≥pia do hist√≥rico atual e adicionamos o evento de troca.
                    const historyArray = [...(currentGame.history || [])];

                    const swapEvent = {
                        type: 'swap',
                        roundNumber: historyArray.length + 1,
                        playerOutId: oldPlayerId, // Guardamos o ID para an√°lise
                        playerInId: newPlayerId,   // Guardamos o ID para an√°lise
                        oldPlayerName: appState.players[oldPlayerId]?.name || 'Jogador Anterior',
                        newPlayerName: appState.players[newPlayerId]?.name || 'Novo Jogador',
                        timestamp: new Date(),
                        // Salvamos o estado dos pontos no momento da troca
                        stateScore: {
                            scores: { ...newScores },
                            raios: { ...newRaios }
                        }
                    };

                    historyArray.push(swapEvent);

                    // 5. Atualiza o turno se era do jogador que saiu
                    let newTurn = currentGame.turn;
                    if (newTurn === oldPlayerId) newTurn = newPlayerId;

                    const updates = {
                        selectedSlots: newSelectedSlots,
                        playerIds: newPlayerIds,
                        scores: newScores,
                        raios: newRaios,
                        history: historyArray,
                        turn: newTurn
                    };

                    await updateDoc(gameDocRef, updates);
                    showMessage("Troca realizada! O hist√≥rico original foi preservado.", "success");

                } catch (error) {
                    console.error("Erro ao realizar a troca:", error);
                    showMessage("Falha ao realizar a troca.", "error");
                }
            }

            async function endGame() {
                const currentGame = appState.gameState.activeGame;

                if (!currentGame || currentGame.history.length === 0) {
                    resetGameState();
                    switchView('view-scoreboard');
                    return;
                }

                const modalHTML = `
                    <h3 class="text-xl font-bold text-red-600">Encerrar Partida</h3>
                    <p class="my-4">Tem certeza que deseja encerrar a partida? O jogador com mais raios (e pontos como desempate) ser√° declarado o vencedor.</p>
                    <div class="flex justify-end gap-3 mt-6">
                        <button id="confirmEndNo" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg">N√£o, continuar</button>
                        <button id="confirmEndYes" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-lg">Sim, encerrar</button>
                    </div>`;
                openModal(modalHTML);

                document.getElementById('confirmEndYes').onclick = async () => {
                    closeModal();

                    let leaderId = null, leaderTeam = null;
                    let maxRaios = -1, maxPoints = -1, isTie = false;

                    if (currentGame.gameMode === 'duplas') {
                        // L√≥gica de duplas (dando prioridade aos raios)
                        const raiosA = currentGame.teams.A.raios || 0;
                        const raiosB = currentGame.teams.B.raios || 0;

                        if (raiosA > raiosB) { leaderTeam = 'A'; }
                        else if (raiosB > raiosA) { leaderTeam = 'B'; }
                        else { // Raios empatados, usa pontos como desempate
                            const scoreA = currentGame.teams.A.score;
                            const scoreB = currentGame.teams.B.score;
                            if (scoreA > scoreB) { leaderTeam = 'A'; }
                            else if (scoreB > scoreA) { leaderTeam = 'B'; }
                            else { isTie = true; }
                        }
                        maxRaios = Math.max(raiosA, raiosB);
                        maxPoints = Math.max(currentGame.teams.A.score, currentGame.teams.B.score);

                    } else { // MODO INDIVIDUAL
                        // --- IN√çCIO DA L√ìGICA CORRIGIDA ---
                        // Percorre todos os jogadores para encontrar o l√≠der baseado em Raios > Pontos
                        for (const playerId of currentGame.playerIds) {
                            const playerRaios = currentGame.raios[playerId] || 0;
                            const playerPoints = currentGame.scores[playerId] || 0;

                            if (playerRaios > maxRaios) {
                                // Novo l√≠der por ter mais raios
                                maxRaios = playerRaios;
                                maxPoints = playerPoints;
                                leaderId = playerId;
                                isTie = false;
                            } else if (playerRaios === maxRaios) {
                                // Raios empatados, verifica os pontos
                                if (playerPoints > maxPoints) {
                                    // Novo l√≠der pelo desempate de pontos
                                    maxPoints = playerPoints;
                                    leaderId = playerId;
                                    isTie = false;
                                } else if (playerPoints === maxPoints) {
                                    // Empate total
                                    isTie = true;
                                }
                            }
                        }
                    }
                    // --- FIM DA L√ìGICA CORRIGIDA ---

                    // Agora, a condi√ß√£o de vit√≥ria verifica se houve um vencedor (sem empate)
                    // e se ele tem ao menos um raio ou um ponto.
                    if (!isTie && (maxRaios > 0 || maxPoints > 0)) {
                        const winnerInfo = currentGame.gameMode === 'duplas' ? { winnerTeam: leaderTeam } : { winnerId: leaderId };
                        const finalGameData = { ...currentGame, status: 'finished', winnerInfo, maxRaios };
                        await processAndShowGameOver(finalGameData);
                    } else {
                        // Se houver empate ou ningu√©m pontuou, a partida √© abortada.
                        const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
                        await updateDoc(gameDocRef, { status: 'aborted', endedAt: serverTimestamp() });
                        resetGameState();
                        switchView('view-scoreboard');
                        showMessage("Partida encerrada sem vencedor.", "info");
                    }
                };

                document.getElementById('confirmEndNo').onclick = () => closeModal();
            }

            async function processAndShowGameOver(gameData) {
                // Previne execu√ß√µes m√∫ltiplas
                if (document.getElementById('view-game-over').classList.contains('active')) return;

                const { gameMode, winnerInfo, teams, scores, playerIds, isRaioMatch, raios } = gameData;
                const batch = writeBatch(db);
                let winnerText = '';
                let finalScoreText = '';

                // (A l√≥gica para determinar o vencedor e o texto final est√° correta e n√£o muda)
                if (gameMode === 'duplas') { /* ... */ }
                else { /* ... */ }

                // Finaliza o documento da partida
                const gameDocRef = doc(matchesCollectionRef(), appState.gameState.activeGameId);
                batch.update(gameDocRef, { status: 'finished', endedAt: serverTimestamp(), winnerInfo: winnerInfo });

                // --- IN√çCIO DA CORRE√á√ÉO ---
                // A √∫nica estat√≠stica a ser atualizada no final √© se os jogadores participaram da sess√£o.
                // A l√≥gica de lambreta foi REMOVIDA daqui.
                for (const playerId of playerIds) {
                    const playerDocRef = doc(playersCollectionRef(), playerId);
                    // Esta atualiza√ß√£o de partidasJogadas pode ser opcional, j√° que agora contamos
                    // as partidas por raio ganho. Se quiser contar a "sess√£o" como um todo, mantenha.
                    // Se n√£o, pode remover este loop inteiro. Vou deixar comentado por enquanto.
                    // batch.update(playerDocRef, { partidasJogadas: increment(1) });
                }
                // --- FIM DA CORRE√á√ÉO ---

                appState.gameState.finalGameData = gameData;
                await batch.commit();

                // Exibe a tela de Fim de Jogo
                ui.gameMode.gameOver.winnerText.textContent = winnerText;
                ui.gameMode.gameOver.scoreText.textContent = finalScoreText;

                resetGameState();
                switchView('view-game-over');
            }

            function switchView(viewId) { ui.views.forEach(v => v.classList.toggle('active', v.id === viewId)); }

            function renderScoreboard() {
                const players = Object.values(appState.players);
                const seriesOrder = ['A', 'B', 'C', 'D', 'Amador'];

                players.sort((a, b) => {
                    const statsA = a[currentSeason] || {};
                    const statsB = b[currentSeason] || {};

                    const aproveitamentoDiff = (statsB.aproveitamentoNaTemporada || 0) - (statsA.aproveitamentoNaTemporada || 0);
                    if (aproveitamentoDiff !== 0) return aproveitamentoDiff;

                    const pontosDiff = (statsB.pontosNaTemporada || 0) - (statsA.pontosNaTemporada || 0);
                    if (pontosDiff !== 0) return pontosDiff;

                    return (statsA.lambretasNaTemporada || 0) - (statsB.lambretasNaTemporada || 0);
                });

                ui.playersListDiv.innerHTML = players.map((player, index) => {
                    const stats = player[currentSeason] || {};

                    let cardClasses = "p-4 rounded-xl shadow-sm flex items-center justify-between transition-all duration-200 hover:scale-[1.01]";
                    let positionIcon = "";
                    let positionText = `${index + 1}¬∫`;

                    if (index < 3) {
                        cardClasses += " bg-green-50 border-l-4 border-green-500";
                        positionIcon = ["ü•á", "ü•à", "ü•â"][index] || "";
                    } else if (index >= players.length - 3) {
                        cardClasses += " bg-red-50 border-l-4 border-red-500";
                    } else {
                        cardClasses += " bg-white";
                    }

                    if (index === 0) {
                        cardClasses += " ring-2 ring-yellow-400 animate-pulse";
                        positionText = "üëë " + positionText;
                    }

                    return `
                        <div class="${cardClasses}">
                            <div class="flex items-center gap-3">
                                <span class="font-mono text-sm text-gray-400 w-8 text-center">
                                    ${positionIcon || positionText}
                                </span>
                                <div>
                                    <span class="font-bold text-lg player-name-clickable" data-player-id="${player.id}">
                                        ${player.name}
                                    </span>
                                    <span class="text-sm text-gray-500 ml-2">
                                        (S√©rie ${player.series})
                                    </span>
                                </div>
                            </div>
                            <div class="text-sm font-mono leading-tight text-right">
                                <div class="grid grid-cols-4 text-gray-500 w-44 mx-auto">
                                    <span class="text-center">RT</span>
                                    <span class="text-center">LT</span>
                                    <span class="text-center">PAT</span>
                                    <span class="text-center">SR</span>
                                </div>
                                <div class="grid grid-cols-4 font-semibold w-44 mx-auto">
                                    <span class="text-blue-600 text-center">${stats.raiosNaTemporada || 0}</span>
                                    <span class="text-yellow-600 text-center">${stats.lambretasNaTemporada || 0}</span>
                                    <span class="text-center">${stats.partidasNaTemporada || 0}</span>
                                    <span class="text-center">${(stats.aproveitamentoNaTemporada || 0).toFixed(1)}%</span>
                                </div>
                            </div>
                        </div>
                    `;

                }).join('');
            }

            async function atualizarAproveitamentoTemporada(playerId) {
                const playerRef = doc(playersCollectionRef(), playerId);
                const playerSnap = await getDoc(playerRef);
                if (!playerSnap.exists()) return;

                const player = playerSnap.data();
                const stats = player[currentSeason] || {};
                const aproveitamento = stats.partidasNaTemporada > 0
                    ? (stats.raiosNaTemporada / stats.partidasNaTemporada) * 100
                    : 0;

                await updateDoc(playerRef, {
                    [`${currentSeason}.aproveitamentoNaTemporada`]: aproveitamento
                });
            }

            async function concederConquista(playerId, conquistaId, textoDoEvento) {
                const player = appState.players[playerId];
                const playerDocRef = doc(playersCollectionRef(), playerId);

                // Para conquistas de uma s√≥ vez, como 'primeiro_rei', a verifica√ß√£o
                // deve ser feita ANTES de chamar esta fun√ß√£o.
                // Esta fun√ß√£o agora SEMPRE incrementa o contador.

                try {
                    // Usa a nota√ß√£o de ponto para atualizar um campo dentro de um objeto (mapa)
                    // e a fun√ß√£o increment() para adicionar +1 de forma segura.
                    await updateDoc(playerDocRef, {
                        [`conquistas.${conquistaId}`]: increment(1),
                        [`${currentSeason}.conquistasNaTemporada.${conquistaId}`]: increment(1)
                    });


                    // Registra o feito no feed de atividades
                    await registrarEvento('achievement', playerId, textoDoEvento);

                    showMessage(`${player.name} ${textoDoEvento}`, 'success');

                } catch (error) {
                    console.error("Erro ao conceder conquista:", error);
                    showMessage("Erro ao processar conquista.", "error");
                }
            }

            function showGameSummary() {
                const gameHistory = appState.gameState.finalGameData.history;
                if (!gameHistory || gameHistory.length === 0) return;

                let summaryHTML = `<h3 class="text-2xl font-bold mb-4">Resumo da Partida</h3><div class="space-y-4 max-h-96 overflow-y-auto">`;

                gameHistory.forEach(round => {
                    const winnerName = appState.players[round.winnerId].name;
                    summaryHTML += `
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <p class="font-bold text-lg">Rodada ${round.roundNumber}: <span class="text-blue-600">${winnerName}</span> venceu</p>
                            ${round.completedRaio ? '<p class="text-sm font-semibold text-yellow-600">‚ö°Ô∏è RAIO COMPLETO! ‚ö°Ô∏è</p>' : ''}
                            <div class="text-xs text-gray-600 mt-2">
                                <p>Placar de Raios: ${Object.entries(round.stateScore.raios).map(([pid, r]) => `${appState.players[pid].name}: ${r}`).join(', ')}</p>
                                <p>Placar de Pontos: ${Object.entries(round.stateScore.scores).map(([pid, s]) => `${appState.players[pid].name}: ${s}`).join(', ')}</p>}
                            </div>
                        </div>
                    `;
                });

                summaryHTML += `</div>`;
                openModal(summaryHTML);
            }

            async function registrarEvento(type, playerId, text) {
                try {
                    const player = appState.players[playerId];
                    if (!player) {
                        console.error("Tentativa de registrar evento para jogador desconhecido:", playerId);
                        return;
                    }

                    const eventData = {
                        type: type, // 'promotion', 'demotion', 'achievement'
                        player: player.name,
                        text: text,
                        timestamp: serverTimestamp()
                    };
                    await addDoc(activityFeedCollectionRef(), eventData);
                } catch (error) {
                    console.error("Erro ao registrar evento:", error);
                }
            }

            function renderActivityFeed() {
                ui.activityFeedDiv.innerHTML = appState.activityFeed.length === 0 ? '<p class="text-gray-500 text-center">Nenhuma atividade recente.</p>' :
                    appState.activityFeed.map(item => {
                        let icon = 'üí¨';
                        if (item.type === 'promotion') icon = '‚ñ≤';
                        else if (item.type === 'demotion') icon = '‚ñº';
                        else if (item.type === 'stagnant') icon = 'üìç';
                        else if (item.type === 'achievement') icon = '‚≠ê';
                        const color = item.type === 'promotion' ? 'green' : (item.type === 'demotion' ? 'red' : 'yellow');
                        const timestamp = item.timestamp?.seconds ? new Date(item.timestamp.seconds * 1000).toLocaleString('pt-BR') : 'agora';
                        return `<div class="p-3 rounded-lg flex items-center gap-3"><span class="text-${color}-500">${icon}</span><div><p class="text-gray-800"><span class="font-semibold">${item.player}</span> ${item.text}</p><p class="text-xs text-gray-400">${timestamp}</p></div></div>`;
                    }).join('');
            }

            function renderVisualScoreboard(gameData) {
                const scoreboardDiv = document.getElementById('liveMatchScoreboard');
                if (!scoreboardDiv) return;

                const { playerIds, scores, raios, isRaioMatch } = gameData;
                let scoreboardHTML = '';

                playerIds.forEach(playerId => {
                    const player = appState.players[playerId];
                    if (!player) return;

                    const currentPontos = scores?.[playerId] || 0;
                    const currentRaios = raios?.[playerId] || 0;

                    // Gera os 4 c√≠rculos de pontos
                    let pointsHTML = '';
                    for (let i = 1; i <= 4; i++) {
                        const pointColor = i <= currentPontos ? 'bg-yellow-400' : 'bg-gray-300';
                        pointsHTML += `<div class="w-4 h-4 rounded-full ${pointColor} border-2 border-white"></div>`;
                    }

                    // Gera o contador de raios
                    const raioCounterHTML = currentRaios > 1 ? `
                        <span class="ml-1 text-sm font-bold text-yellow-700">(x${currentRaios})</span>
                    ` : '';

                    const raiosDisplayHTML = currentRaios > 0 ? `
                        <div class="flex items-center justify-center text-2xl mt-2">
                            <span>‚ö°Ô∏è</span>
                            ${raioCounterHTML}
                        </div>
                    ` : '<div class="h-9"></div>'; // Espa√ßo reservado para manter a altura

                    scoreboardHTML += `
                        <div class="bg-gray-50 p-2 rounded-lg text-center shadow">
                            <p class="font-bold text-sm truncate">${player.name}</p>
                            <div class="flex justify-center items-center gap-1.5 my-2">
                                ${pointsHTML}
                            </div>
                            ${raiosDisplayHTML}
                        </div>
                    `;
                });

                scoreboardDiv.innerHTML = scoreboardHTML;
            }

            function renderHistoryFeed(gameData) {
                const historyDiv = document.getElementById('liveMatchHistory');
                if (!historyDiv) return;

                const history = gameData.history || [];
                if (history.length === 0) {
                    historyDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Aguardando a primeira rodada...</p>';
                    return;
                }

                // REMOVEMOS o .slice(-5). Agora pegamos tudo e apenas invertemos para o mais novo ficar no topo.
                const fullHistoryReversed = [...history].reverse();

                historyDiv.innerHTML = fullHistoryReversed.map(round => {
                    let eventHTML = '';

                    if (round.type === 'swap') {
                        eventHTML = `
                            <p class="text-gray-800 text-sm italic">
                                Troca de jogadores üîÑ Saiu <span class="font-semibold">${round.oldPlayerName}</span> e entrou <span class="font-semibold">${round.newPlayerName}</span>.
                            </p>`;
                    } else {
                        const winnerName = appState.players[round.winnerId]?.name || 'Desconhecido';
                        let roundText = round.completedRaio ?
                            `ganhou um <strong>Raio! ‚ö°Ô∏è</strong>` :
                            `marcou um ponto.`;

                        eventHTML = `
                            <p class="text-sm text-gray-800">
                                <span class="font-semibold text-gray-400">Rod. ${round.roundNumber}:</span>
                                <span class="font-bold">${winnerName}</span> ${roundText}
                            </p>`;
                    }

                    return `<div class="p-2 border-t border-gray-50 first:border-t-0 hover:bg-gray-50 transition-colors">${eventHTML}</div>`;
                }).join('');
            }

            function renderLiveMatchFeed(gameData) {
                const feedContainer = document.getElementById('liveMatchFeed');
                if (!feedContainer) return;

                // Adicionamos as classes de scroll e altura m√°xima no container do hist√≥rico
                feedContainer.innerHTML = `
                    <div id="liveMatchScoreboard" class="grid grid-cols-2 md:grid-cols-4 gap-2 pb-4 border-b border-gray-200">
                    </div>
                    <div id="liveMatchHistory" class="pt-2 max-h-48 overflow-y-auto scrollbar-thin scrollbar-thumb-gray-300">
                    </div>
                `;

                renderVisualScoreboard(gameData);
                renderHistoryFeed(gameData);
            }

            function openModal(html) {
                ui.modal.content.innerHTML = html;

                // Mostra o container
                ui.modal.container.style.display = 'block'; // Usando block para o overflow-y funcionar melhor

                // TRAVA O SCROLL DO FUNDO
                document.body.classList.add('modal-open');

                // Esconde o bot√£o flutuante (FAB)
                const fabContainer = document.querySelector('.admin-fab-container');
                if (fabContainer) fabContainer.classList.add('hidden');

                // Garante que o modal comece no topo ao abrir
                ui.modal.container.scrollTop = 0;
            }

            function closeModal() {
                ui.modal.container.style.display = 'none';
                ui.modal.content.innerHTML = '';

                // DESTRAVA O SCROLL DO FUNDO
                document.body.classList.remove('modal-open');

                // Mostra novamente o FAB
                const fabContainer = document.querySelector('.admin-fab-container');
                if (fabContainer) fabContainer.classList.remove('hidden');
            }

            // function openModal(contentHTML) { ui.modal.content.innerHTML = contentHTML; ui.modal.container.style.display = 'flex'; }
            // function closeModal() { ui.modal.container.style.display = 'none'; }

            async function updatePlayerStat(playerId, stat, amount) {
                if (!appState.isAdminMode) return;

                const playerDocRef = doc(playersCollectionRef(), playerId);

                try {
                    const playerDoc = await getDoc(playerDocRef);
                    if (!playerDoc.exists()) {
                        showMessage("Erro: Jogador n√£o encontrado.", "error");
                        return;
                    }
                    const player = playerDoc.data();

                    const updates = {};

                    // --- IN√çCIO DA CORRE√á√ÉO ---
                    // L√≥gica corrigida para lidar com o plural de "lambreta"
                    let seriesStatName = '';
                    if (stat === 'lambreta') {
                        seriesStatName = 'lambretasNaSerie';
                    } else {
                        seriesStatName = `${stat}NaSerie`;
                    }
                    // --- FIM DA CORRE√á√ÉO ---

                    const currentStatValue = player[stat] || 0;
                    const currentSeriesValue = player[seriesStatName] || 0;

                    if (currentStatValue + amount < 0) {
                        showMessage(`N√£o √© poss√≠vel ter valor negativo para ${stat}.`, 'error');
                        return;
                    }

                    updates[stat] = increment(amount);

                    if (currentSeriesValue + amount >= 0) {
                        updates[seriesStatName] = increment(amount);
                    } else {
                        updates[seriesStatName] = -1;
                        // console.warn(`Contador de s√©rie para "${stat}" j√° est√° em 0.`);
                    }

                    if (Object.keys(updates).length > 0) {
                        await updateDoc(playerDocRef, updates);
                    }

                    // const changes = await checarStatusDaSerie(playerId);
                    // await applySeriesChanges(playerId, changes);

                } catch (error) {
                    console.error(`Erro ao atualizar ${stat}:`, error);
                    showMessage(`Erro ao atualizar ${stat}.`, 'error');
                }
            }

            function openPlayerDetailsModal(playerId) {
                appState.modalContext = { currentViewedPlayerId: playerId };
                const player = appState.players[playerId];
                if (!player) return;

                const s = player[currentSeason] || {};

                // --- 1. C√ÅLCULOS GLOBAIS ---
                const totalPartidas = player.partidasJogadas || 0;
                const aprovRaiosGlobal = totalPartidas > 0 ? ((player.raios / totalPartidas) * 100).toFixed(1) : "0";
                const aprovLambretasGlobal = totalPartidas > 0 ? ((player.lambreta / totalPartidas) * 100).toFixed(1) : "0";

                // --- 2. C√ÅLCULOS DA TEMPORADA ---
                const partidasTemporada = s.partidasNaTemporada || 0;
                const aprovRaiosTemp = s.aproveitamentoNaTemporada || 0;
                const aprovLambTemp = partidasTemporada > 0 ? (((s.lambretasNaTemporada || 0) / partidasTemporada) * 100).toFixed(1) : "0";

                // --- 3. GALERIA DE TROF√âUS (GERAL) ---
                const achievementsHTML = Object.keys(achievements).map(key => {
                    const ach = achievements[key];
                    const countGeral = player.conquistas?.[key] || 0;
                    const countTemporada = s.conquistasNaTemporada?.[key] || 0;
                    const countTotal = countGeral + countTemporada;

                    if (countTotal === 0) return '';

                    const counterHTML = countTotal > 1
                        ? `<span class="absolute -top-1 -right-1 bg-red-600 text-white text-[9px] font-bold rounded-full h-4 w-4 flex items-center justify-center border border-white">${countTotal}</span>`
                        : '';

                    return `
                        <div class="relative flex flex-col items-center bg-gray-50 p-2 rounded-xl border border-gray-100 min-w-[65px]">
                            <span class="text-2xl" title="${ach.description}">${ach.icon}</span>
                            <p class="text-[8px] font-bold text-gray-500 uppercase mt-1 text-center leading-tight">${ach.name}</p>
                            ${counterHTML}
                        </div>`;
                }).join('');

                // --- 4. CONQUISTAS ESPEC√çFICAS DA TEMPORADA (DETALHADO) ---
                const conquistasTemporadaHTML = s.conquistasNaTemporada && Object.keys(s.conquistasNaTemporada).length > 0
                    ? Object.keys(s.conquistasNaTemporada).map(key => {
                        const ach = achievements[key]; // Busca no dicion√°rio global pelo ID que est√° na temporada
                        if (!ach) return '';
                        return `
                            <div class="bg-green-50 px-2 py-1 rounded border border-green-100 flex items-center gap-1">
                                <span class="text-sm">${ach.icon}</span>
                                <span class="text-[8px] font-bold text-green-700 uppercase">${ach.name}</span>
                            </div>`;
                    }).join('')
                    : '<p class="text-[10px] text-gray-400 italic">Nenhum trof√©u nesta temporada ainda...</p>';

                const generateStatControlHTML = (stat, label) => {
                    const value = player[stat] || 0;
                    return `
                        <div class="bg-gray-50 p-2 rounded-lg border border-gray-100 font-mono">
                            <p class="text-[9px] uppercase font-bold text-gray-400 mb-1">${label}</p>
                            <div class="flex items-center justify-between">
                                <span class="text-lg font-bold text-gray-700">${value}</span>
                                ${appState.isAdmin ? `
                                    <div class="flex gap-1">
                                        <button onclick="updateStat('${playerId}', '${stat}', -1)" class="w-5 h-5 bg-red-100 text-red-600 rounded flex items-center justify-center text-xs">-</button>
                                        <button onclick="updateStat('${playerId}', '${stat}', 1)" class="w-5 h-5 bg-green-100 text-green-600 rounded flex items-center justify-center text-xs">+</button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                };

                const modalHTML = `
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h3 class="text-2xl font-bold text-gray-800">${player.name}</h3>
                            <p class="text-[10px] text-blue-600 uppercase tracking-widest font-black">Performance Geral</p>
                        </div>
                        <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-3xl">&times;</button>
                    </div>

                    <div class="grid grid-cols-2 gap-3 mb-6">
                        <div class="bg-gradient-to-br from-yellow-50 to-orange-50 border border-yellow-100 p-3 rounded-xl">
                            <p class="text-[9px] uppercase font-black text-yellow-700">Aprov. Raios Global</p>
                            <p class="text-2xl font-black text-yellow-900">${aprovRaiosGlobal}%</p>
                        </div>
                        <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-100 p-3 rounded-xl">
                            <p class="text-[9px] uppercase font-black text-blue-700">Aprov. Lambretas Global</p>
                            <p class="text-2xl font-black text-blue-900">${aprovLambretasGlobal}%</p>
                        </div>
                    </div>

                    <div class="mb-6 px-1">
                        <h4 class="text-[10px] font-black text-gray-400 uppercase mb-2">Galeria de Trof√©us</h4>
                        <div class="flex flex-wrap gap-2">
                            ${achievementsHTML || '<p class="text-xs text-gray-300 italic font-medium">Nenhum trof√©u ainda.</p>'}
                        </div>
                    </div>

                    <div class="bg-white border-t-2 border-green-500 rounded-2xl p-4 mb-6 shadow-sm border border-gray-100">
                        <h4 class="text-xs font-black text-gray-700 uppercase mb-3 flex justify-between items-center">
                            <span>Temporada Atual</span>
                            <span class="bg-green-100 text-green-700 px-2 py-0.5 rounded text-[9px] font-black">${currentSeason}</span>
                        </h4>

                        <div class="grid grid-cols-4 text-[9px] text-gray-400 uppercase font-bold text-center mb-1">
                            <span>Lamb.</span><span>Raios</span><span>Part.</span><span>MP</span>
                        </div>
                        <div class="grid grid-cols-4 font-bold text-gray-800 text-center mb-4 border-b border-gray-50 pb-2 font-mono">
                            <span class="text-blue-600">${s.lambretasNaTemporada || 0}</span>
                            <span class="text-yellow-600">${s.raiosNaTemporada || 0}</span>
                            <span>${s.partidasNaTemporada || 0}</span>
                            <span>${s.matchPointsNaTemporada || 0}</span>
                        </div>

                        <div class="space-y-4 mb-5">
                            <div>
                                <div class="flex justify-between text-[10px] font-bold uppercase mb-1">
                                    <span class="text-gray-500">Aprov. Raios (Temp.)</span>
                                    <span class="text-yellow-600">${aprovRaiosTemp}%</span>
                                </div>
                                <div class="w-full bg-gray-100 h-1.5 rounded-full overflow-hidden">
                                    <div class="bg-yellow-500 h-full" style="width: ${aprovRaiosTemp}%"></div>
                                </div>
                            </div>
                            <div>
                                <div class="flex justify-between text-[10px] font-bold uppercase mb-1">
                                    <span class="text-gray-500">Aprov. Lambretas (Temp.)</span>
                                    <span class="text-blue-600">${aprovLambTemp}%</span>
                                </div>
                                <div class="w-full bg-gray-100 h-1.5 rounded-full overflow-hidden">
                                    <div class="bg-blue-600 h-full" style="width: ${aprovLambTemp}%"></div>
                                </div>
                            </div>
                        </div>

                        <h5 class="text-[9px] font-black text-gray-400 uppercase mb-2">Conquistado nesta temporada:</h5>
                        <div class="flex flex-wrap gap-2">
                            ${conquistasTemporadaHTML}
                        </div>
                    </div>

                    <h4 class="text-[10px] font-black text-gray-400 uppercase mb-2 px-1">Totais de Carreira</h4>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        ${generateStatControlHTML('partidasJogadas', 'Partidas')}
                        ${generateStatControlHTML('raios', 'Raios')}
                        ${generateStatControlHTML('lambreta', 'Lambretas')}
                        ${generateStatControlHTML('pontos', 'Pontos')}
                    </div>

                    ${appState.isAdminMode ? `
                        <div class="mt-6 pt-4 border-t border-gray-100">
                            <button onclick="deletarJogador('${playerId}')"
                                    class="w-full bg-red-50 text-red-600 py-3 rounded-xl font-bold text-xs uppercase tracking-widest hover:bg-red-100 transition-colors">
                                EXCLUIR JOGADOR
                            </button>
                        </div>
                    ` : ''}
                `;

                openModal(modalHTML);
                document.getElementById('modal-close-btn').onclick = closeModal;
            }

            function createInitialGameState() { return { gameMode: 'individual', isRaioMatch: false, selectedSlots: { 1: null, 2: null, 3: null, 4: null }, activeGame: null, activeGameId: null, activeGameListener: null }; }

            function resetGameState() {
                if (appState.gameState.activeGameListener) {
                    appState.gameState.activeGameListener();
                }

                // --- IN√çCIO DA CORRE√á√ÉO ---
                // 1. Salva a refer√™ncia aos dados do jogo final, se eles existirem.
                const finalData = appState.gameState.finalGameData;

                // 2. Cria o novo estado de jogo limpo, como antes.
                appState.gameState = createInitialGameState();

                // 3. Se havia dados de um jogo final, restaura eles no novo estado.
                if (finalData) {
                    appState.gameState.finalGameData = finalData;
                }
                // --- FIM DA CORRE√á√ÉO ---

                // O resto da fun√ß√£o continua igual, limpando a interface.
                ui.gameMode.statusText.textContent = 'Selecione os jogadores para come√ßar';
                ui.gameMode.startBtn.style.display = 'block';
                ui.gameMode.activeButtons.style.display = 'none';
                document.getElementById('game-type-selector').style.display = 'flex';
                document.getElementById('raio-mode-selector').style.display = 'flex';
                ui.gameMode.raioCheckbox.checked = false;
                updateGameModeUI();
            }

            function updateGameModeUI() {
                ui.gameMode.modeButtons.forEach(btn => btn.className = `gameModeBtn font-semibold py-2 px-4 rounded-lg ${btn.dataset.mode === appState.gameState.gameMode ? 'shadow bg-blue-500 text-white' : 'bg-white text-gray-500'}`);
                resetPlayerSlots();
            }

            function resetPlayerSlots() {
                appState.gameState.selectedSlots = { 1: null, 2: null, 3: null, 4: null };
                renderAllSlots();
            }

            function renderAllSlots() {
                document.querySelectorAll('.player-slot').forEach(slot => renderPlayerSlot(slot.id.split('-')[1]));
                checkStartGameCondition();
            }

            function renderPlayerSlot(slotId) {
                const slotDiv = document.getElementById(`slot-${slotId}`);

                // Determina a fonte de dados correta para os slots
                const slotsSource = appState.gameState.activeGame ? appState.gameState.activeGame.selectedSlots : appState.gameState.selectedSlots;
                const playerId = slotsSource?.[slotId];
                const player = playerId ? appState.players[playerId] : null;

                slotDiv.innerHTML = ''; // Limpa o conte√∫do anterior do slot

                if (player) {
                    let scoreHTML = '';
                    // Se um jogo est√° ativo, busca os dados de placar e gera o HTML
                    if (appState.gameState.activeGame) {
                        const gameData = appState.gameState.activeGame;
                        const raios = gameData.raios?.[playerId] || 0;
                        const pontos = gameData.scores?.[playerId] || 0;
                        scoreHTML = generateScoreHTML(raios, pontos, gameData.isRaioMatch);
                    }

                    let teamIndicator = '';
                    if (appState.gameState.gameMode === 'duplas') {
                        let teamName = (['2', '4'].includes(String(slotId))) ? 'Time A' : 'Time B';
                        let teamColor = (teamName === 'Time A') ? 'bg-blue-200 text-blue-800' : 'bg-red-200 text-red-800';
                        teamIndicator = `<div class="text-xs font-bold px-2 py-0.5 rounded-full ${teamColor}">${teamName}</div>`;
                    }

                    // Constr√≥i o HTML completo do card do jogador, incluindo o scoreHTML
                    slotDiv.innerHTML = `
                        <div class="bg-white p-3 rounded-lg shadow-md text-center w-15 sm:w-40 transition-all transform hover:scale-105" data-player-id-on-table="${playerId}">
                            <div class="font-bold text-lg truncate">${player.name}</div>
                            <div class="text-sm text-gray-500 mb-2">${player.series}</div>
                            ${teamIndicator}
                            <div id="score-${slotId}" class="flex flex-wrap justify-center items-center gap-2 mt-2 h-auto min-h-[20px] text-2xl">
                                ${scoreHTML}
                            </div>
                        </div>
                    `;
                } else {
                    // L√≥gica para renderizar o bot√£o '+' (n√£o muda)
                    let legendHTML = '';
                    if (appState.gameState.gameMode === 'duplas') {
                        legendHTML = `<div class="team-legend text-${(['2', '4'].includes(String(slotId)) ? 'blue' : 'red')}-300 text-xs mt-1 font-semibold">${(['2', '4'].includes(String(slotId)) ? 'Time A' : 'Time B')}</div>`;
                    }
                    slotDiv.innerHTML = `<button class="add-player-btn w-20 h-20 bg-white/20 rounded-full flex items-center justify-center text-4xl text-white/50 hover:bg-white/40 transition" data-slot-id="${slotId}">+</button>${legendHTML}`;
                    slotDiv.querySelector('.add-player-btn').addEventListener('click', () => openPlayerSelectionModal(slotId));
                }
            }

            function openPlayerSelectionModal(slotId) {
                if (appState.gameState.activeGame) return;
                appState.gameState.targetSlot = slotId;
                const availablePlayers = Object.values(appState.players).filter(p => !Object.values(appState.gameState.selectedSlots).includes(p.id));
                const modalHTML = `<h3 class="text-2xl font-bold mb-4">Selecione um Jogador</h3><div class="space-y-2 max-h-64 overflow-y-auto">${availablePlayers.map(p => `<button class="w-full text-left p-3 bg-gray-100 rounded-lg hover:bg-blue-100 transition player-select-btn" data-player-id="${p.id}">${p.name}</button>`).join('')}</div><button id="modal-cancel-btn" class="mt-6 bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg w-full">Cancelar</button>`;
                openModal(modalHTML);
            }

            function selectPlayer(playerId) {
                const currentSlotOfPlayer = Object.keys(appState.gameState.selectedSlots).find(key => appState.gameState.selectedSlots[key] === playerId);
                if (currentSlotOfPlayer) appState.gameState.selectedSlots[currentSlotOfPlayer] = null;
                appState.gameState.selectedSlots[appState.gameState.targetSlot] = playerId;
                closeModal();
                renderAllSlots();
            }

            function checkStartGameCondition() {
                const selectedCount = Object.values(appState.gameState.selectedSlots).filter(Boolean).length;
                const canStart = (appState.gameState.gameMode === 'duplas') ? (selectedCount === 4) : (selectedCount >= 2);
                ui.gameMode.startBtn.disabled = !canStart;
                ui.gameMode.startBtn.className = canStart ? 'bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition' : 'bg-gray-400 text-white font-bold py-3 px-6 rounded-lg shadow-md cursor-not-allowed';
            }

            function processMessageQueue() {
                // Se uma mensagem j√° estiver na tela, ou se a fila estiver vazia, n√£o faz nada.
                if (appState.isMessageShowing || appState.messageQueue.length === 0) {
                    return;
                }

                // Marca que a tela est√° "ocupada" mostrando uma mensagem.
                appState.isMessageShowing = true;

                // Pega a primeira mensagem da fila.
                const messageData = appState.messageQueue.shift();
                const messageBox = ui.messageBox;

                let baseClasses = 'fixed left-1/2 -translate-x-1/2 w-auto min-w-[320px] max-w-[90%] py-3 px-5 rounded-lg shadow-2xl text-white font-semibold z-[1002] transition-all duration-500 ease-in-out';
                let typeClasses = '';

                switch (messageData.type) {
                    case 'success': typeClasses = 'bg-green-600'; break;
                    case 'error': typeClasses = 'bg-red-600'; break;
                    default: typeClasses = 'bg-blue-600'; break;
                }

                // Mostra a mensagem
                messageBox.className = `${baseClasses} ${typeClasses} -top-24`;
                messageBox.textContent = messageData.text;
                messageBox.style.display = 'block';

                // Anima√ß√£o de entrada
                setTimeout(() => {
                    messageBox.classList.remove('-top-24');
                    messageBox.classList.add('top-5');
                }, 50);

                // Agenda a anima√ß√£o de sa√≠da e a limpeza
                setTimeout(() => {
                    messageBox.classList.remove('top-5');
                    messageBox.classList.add('-top-24');

                    // Espera a anima√ß√£o de sa√≠da terminar
                    setTimeout(() => {
                        messageBox.style.display = 'none';
                        // Libera a tela para a pr√≥xima mensagem
                        appState.isMessageShowing = false;
                        // Chama a si mesma para verificar se h√° mais mensagens na fila
                        processMessageQueue();
                    }, 500); // Deve ser igual √† dura√ß√£o da transi√ß√£o CSS

                }, 4000); // Tempo que a mensagem fica vis√≠vel
            }

            function showMessage(message, type = 'info') {
                // Adiciona o objeto da mensagem na nossa fila de espera.
                appState.messageQueue.push({ text: message, type: type });
                // Tenta processar a fila. Se a tela estiver livre, a mensagem ser√° exibida.
                // Se n√£o, ela esperar√° sua vez.
                processMessageQueue();
            }

            async function addNovoJogador() {
                if (!appState.isAdminMode) {
                    showMessage("Voc√™ precisa estar no Modo Administrador para adicionar jogadores.", 'error');
                    return;
                }

                // 1. Construir o HTML do modal usando as classes TailwindCSS do seu projeto.
                const modalHTML = `
                    <div class="flex justify-between items-start">
                        <h3 class="text-2xl font-bold">Adicionar Novo Jogador</h3>
                        <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
                    </div>
                    <div class="mt-4">
                        <label for="newPlayerNameInput" class="block text-sm font-medium text-gray-700 mb-1">Nome do Jogador</label>
                        <input type="text" id="newPlayerNameInput" placeholder="Digite o nome aqui" class="w-full border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="mt-6 flex justify-end gap-3">
                        <button id="cancelAddPlayerBtn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">Cancelar</button>
                        <button id="saveAddPlayerBtn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Adicionar Jogador</button>
                    </div>
                `;

                // 2. Abrir o modal padr√£o da aplica√ß√£o com o conte√∫do criado.
                openModal(modalHTML);

                const newPlayerNameInput = document.getElementById('newPlayerNameInput');
                newPlayerNameInput.focus(); // Foco autom√°tico no campo de input.

                // 3. Adicionar os event listeners para os novos bot√µes dentro do modal.
                document.getElementById('saveAddPlayerBtn').onclick = async () => {
                    const newName = newPlayerNameInput.value.trim();
                    if (newName) {
                        try {
                            await addDoc(playersCollectionRef(), {
                                name: newName,
                                raios: 0,
                                partidasJogadas: 0,
                                lambreta: 0,
                                pontos: 0,
                                series: 'D',
                                conquistas: {},
                                [currentSeason]: {
                                lambretasNaTemporada: 0,
                                raiosNaTemporada: 0,
                                pontosNaTemporada: 0,
                                matchPointsNaTemporada: 0,
                                partidasNaTemporada: 0,
                                conquistasNaTemporada:{}
                                }

                            });
                            // A fun√ß√£o showMessage continua sendo usada para feedback r√°pido no topo da tela.
                            showMessage(`Jogador "${newName}" adicionado com sucesso!`, 'success');
                            closeModal(); // Fecha o modal ap√≥s o sucesso.
                        } catch (error) {
                            console.error("Erro ao adicionar jogador:", error);
                            showMessage("Erro ao adicionar jogador. Tente novamente.", 'error');
                        }
                    } else {
                        showMessage("O nome do jogador n√£o pode ser vazio.", 'error');
                    }
                };

                // O bot√£o de cancelar agora tamb√©m usa a fun√ß√£o padr√£o de fechar.
                document.getElementById('cancelAddPlayerBtn').onclick = () => {
                    closeModal();
                };
            }

            async function renomearJogador(playerId) {
                if (!appState.isAdminMode) {
                    showMessage("A√ß√£o n√£o permitida.", 'error');
                    return;
                }
                const player = appState.players[playerId];
                const playerDocRef = doc(playersCollectionRef(), playerId);

                // Usa o sistema de modal padr√£o
                const modalHTML = `
                    <div class="flex justify-between items-start">
                        <h3 class="text-2xl font-bold">Renomear Jogador</h3>
                        <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 text-2xl">&times;</button>
                    </div>
                    <div class="mt-4">
                        <label for="reNamePlayerInput" class="block text-sm font-medium text-gray-700 mb-1">Novo nome para ${player.name}</label>
                        <input type="text" id="reNamePlayerInput" value="${player.name}" class="w-full border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="mt-6 flex justify-end gap-3">
                        <button id="cancelRenamePlayerBtn" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition">Cancelar</button>
                        <button id="saveRenamePlayerBtn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition">Salvar Altera√ß√µes</button>
                    </div>`;
                openModal(modalHTML);

                const reNamePlayerInput = document.getElementById('reNamePlayerInput');
                reNamePlayerInput.focus();
                reNamePlayerInput.select();

                document.getElementById('saveRenamePlayerBtn').onclick = async () => {
                    const newName = reNamePlayerInput.value.trim();
                    if (newName && newName !== player.name) {
                        try {
                            await updateDoc(playerDocRef, { name: newName });
                            showMessage(`Jogador renomeado para "${newName}".`, 'success');
                            closeModal();
                        } catch (error) {
                            console.error("Erro ao renomear jogador:", error);
                            showMessage("Erro ao renomear jogador. Tente novamente.", 'error');
                        }
                    } else if (newName === player.name) {
                        closeModal(); // Apenas fecha se o nome for o mesmo
                    } else {
                        showMessage("O nome n√£o pode ser vazio.", 'error');
                    }
                };
                document.getElementById('cancelRenamePlayerBtn').onclick = () => closeModal();
            }

            async function deletarJogador(playerId) {
                // 1. Verifica√ß√£o de Seguran√ßa (Admin)
                if (!appState.isAdminMode) {
                    showMessage("A√ß√£o n√£o permitida. Voc√™ precisa estar em modo Admin.", 'error');
                    return;
                }

                const player = appState.players[playerId];
                if (!player) return;

                // 2. Pedido de Confirma√ß√£o (Sua solicita√ß√£o)
                const confirmacao = confirm(`‚ö†Ô∏è ATEN√á√ÉO: Tem certeza que deseja excluir o jogador "${player.name}"?\n\nIsso remover√° permanentemente todos os dados, estat√≠sticas e conquistas dele de todas as temporadas. Esta a√ß√£o n√£o pode ser desfeita.`);

                if (confirmacao) {
                    try {
                        // 3. Refer√™ncia correta do documento no Firestore
                        // O caminho segue o padr√£o do seu projeto: artifacts/ID/public/data/players
                        const playerDocRef = doc(db, `artifacts/${appIdentifier}/public/data/players`, playerId);

                        await deleteDoc(playerDocRef);

                        // 4. Feedback e Limpeza
                        closeModal();
                        showMessage(`Jogador "${player.name}" removido com sucesso.`, 'success');

                        // O listener do Firestore (onSnapshot) cuidar√° de atualizar a lista na tela automaticamente
                    } catch (error) {
                        console.error("Erro ao deletar jogador:", error);
                        showMessage("Erro t√©cnico ao tentar excluir o jogador no banco de dados.", 'error');
                    }
                }
            }

            // 5. ESSENCIAL: Torna a fun√ß√£o vis√≠vel para o 'onclick' do bot√£o no modal
            window.deletarJogador = deletarJogador;

            function setupFirestoreListeners() {
                // Limpa listeners antigos para evitar duplica√ß√£o
                appState.unsubscribers.forEach(unsub => unsub());
                appState.unsubscribers = [];

                // Listener para a lista de jogadores (n√£o muda)
                const unsubPlayers = onSnapshot(query(playersCollectionRef()), (snapshot) => {
                    const newPlayersData = {};
                    snapshot.forEach(doc => {
                        const newPlayer = { id: doc.id, ...doc.data() };
                        const oldPlayer = appState.players[doc.id];
                        newPlayersData[doc.id] = newPlayer;
                    });
                    appState.players = newPlayersData;
                    renderScoreboard();

                    if (appState.gameState.activeGame) {
                        renderLiveMatchFeed(appState.gameState.activeGame);
                    }
                });

                if(document.getElementById('view-history').classList.contains('active')) {
                    if(!ui.history.detailsView.classList.contains('hidden')) {
                         renderActiveHistoryTab();
                    } else {
                        renderMatchHistoryList();
                    }
                }

                // Listener para o feed de atividades gerais (n√£o muda)
                const unsubFeed = onSnapshot(query(activityFeedCollectionRef(), orderBy("timestamp", "desc"), limit(5)), (snapshot) => {
                    appState.activityFeed = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderActivityFeed();
                });

                // Listener para partidas ao vivo (com verifica√ß√£o de idade)
                const q = query(matchesCollectionRef(), where("status", "==", "active"), limit(1));
                const unsubLiveMatch = onSnapshot(q, (snapshot) => {
                    const header = ui.liveMatchHeader;
                    const chevron = ui.liveMatchChevron;
                    const headerText = header.querySelector('h2');

                    const setInactiveState = () => {
                        header.classList.remove('bg-green-600', 'hover:bg-green-700', 'cursor-pointer', 'animate-pulse');
                        header.classList.add('bg-gray-200', 'text-gray-500', 'cursor-default');
                        headerText.textContent = '‚óã NENHUMA PARTIDA ATIVA';
                        chevron.classList.add('hidden');
                        ui.liveMatchFeed.classList.remove('open');
                        ui.liveMatchFeed.innerHTML = '';
                        appState.gameState.activeGame = null;
                    };

                    if (snapshot.empty) {
                        setInactiveState();
                    } else {
                        const gameData = snapshot.docs[0].data();
                        const gameTimestamp = gameData.createdAt?.toDate();
                        const maxAgeHours = 4; // Define que jogos com mais de 4 horas s√£o "zumbis"

                        // --- IN√çCIO DA NOVA VERIFICA√á√ÉO ---
                        // Se o jogo for muito antigo, trata como inativo
                        if (gameTimestamp && (new Date() - gameTimestamp) / 1000 / 3600 > maxAgeHours) {
                            //  console.log("Jogo ativo encontrado, mas √© muito antigo e ser√° ignorado:", gameData.id);
                            setInactiveState();
                        } else {
                        // --- FIM DA NOVA VERIFICA√á√ÉO ---

                            // Se o jogo √© recente, mostra o estado ativo
                            appState.gameState.activeGame = gameData;

                            header.classList.add('bg-green-600', 'hover:bg-green-700', 'cursor-pointer', 'animate-pulse');
                            header.classList.remove('bg-gray-200', 'text-gray-500', 'cursor-default');
                            headerText.textContent = '‚óè PARTIDA EM ANDAMENTO';
                            chevron.classList.remove('hidden');

                            if (Object.keys(appState.players).length > 0) {
                                renderLiveMatchFeed(gameData);
                            }
                        }
                    }
                });

                appState.unsubscribers.push(unsubPlayers, unsubFeed, unsubLiveMatch);
            }

            async function checarStatusDaSerie(playerId) {
                const player = appState.players[playerId];
                if (!player) return { changed: false };

                const seriesOrder = SERIES_CONFIG.map(s => s.name);
                const currentIndex = seriesOrder.indexOf(player.series || 'Amador');

                let changes = {
                    changed: false,
                    undoSeries: false,
                    newSeries: null,
                    oldSeries: player.series,
                    unlockedAchievements: [],
                    promotion: false,
                    demotion: false,
                    stagnant: false
                };

                // Verifica√ß√£o de promo√ß√£o (15 raios na s√©rie atual)
                if ((player.raiosNaSerie || 0) >= 15 && currentIndex < seriesOrder.length - 1) {
                    changes.newSeries = seriesOrder[currentIndex + 1];
                    changes.changed = true;
                    changes.promotion = true;

                    // Verifica se √© o primeiro a chegar nesta s√©rie
                    const jogadoresNaSerie = Object.values(appState.players).filter(p =>
                        p.series === changes.newSeries && p.id !== playerId
                    );

                    if (jogadoresNaSerie.length === 0) {
                        changes.unlockedAchievements.push('desbravador');
                        await concederConquista(playerId, 'desbravador', `foi o primeiro a alcan√ßar a S√©rie ${changes.newSeries}! üßó‚Äç‚ôÇÔ∏è`);
                    }

                    if (changes.newSeries === 'A') {
                        changes.unlockedAchievements.push('primeiro_rei');
                    }
                }
                else if ((player.raiosNaSerie || 0) >= 15 && seriesOrder.length - 1){
                    changes.stagnant = true;
                    changes.changed = true;
                }
                else if ((player.raiosNaSerie || 0) === -1 && currentIndex > 0){
                    const playerDocRef = doc(playersCollectionRef(), playerId);
                    changes.undoSeries = true;
                    changes.newSeries = seriesOrder[currentIndex - 1];
                    changes.changed = true;
                    changes.demotion = true;
                }
                // Verifica√ß√£o de rebaixamento (15 lambretas na s√©rie atual)
                else if ((player.lambretasNaSerie || 0) >= 15 && currentIndex > 0) {
                    changes.newSeries = seriesOrder[currentIndex - 1];
                    changes.changed = true;
                    changes.demotion = true;
                }
                else if ((player.lambretasNaSerie || 0) >= 15 && currentIndex === 0){
                    changes.stagnant = true;
                    changes.changed = true;
                }

                return changes;
            }

            async function applySeriesChanges(playerId, changes) {
                if (!changes.changed) return;

                const playerDocRef = doc(playersCollectionRef(), playerId);
                const player = appState.players[playerId];
                let updates = {
                series: changes.stagnant ? player.series : changes.newSeries,
                raiosNaSerie: changes.stagnant ? 0 : (changes.undoSeries ? 15 : 0),
                lambretasNaSerie: changes.stagnant ? 0 : (changes.undoSeries ? player.lambretasNaSerie : 0)
                };

                await updateDoc(playerDocRef, updates);

                // Concede conquistas relacionadas a s√©ries

                if (changes.demotion){
                    await concederConquista(playerId, "demotion", `foi rebaixado para S√©rie ${changes.newSeries}`);
                }
                else if (changes.promotion){
                    await concederConquista(playerId, "promotion", `foi promovido para S√©rie ${changes.newSeries}`);
                }
                else if (changes.stagnant){
                    await concederConquista(playerId, "stagnant", player.series === "A" ? `ganhou um raio e contioua na S√©rie  ${player.series}` : `tomou uma lambreta e permanece na S√©rie ${player.series}`);
                }
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    appState.userId = user.uid;
                    setupFirestoreListeners();
                    updateAdminUI(); // <--- ADICIONAR AQUI
                } else {
                    try { await signInAnonymously(auth); } catch(e) { console.error("Erro no login an√¥nimo:", e); }
                }
            });

            function updateAdminUI() {
                const isAdmin = appState.isAdminMode;

                // Mostra/esconde o container do bot√£o "Iniciar Modo Partida"
                const goToGameContainer = document.getElementById('goToGameModeContainer');
                if (goToGameContainer) {
                    goToGameContainer.classList.toggle('hidden', !isAdmin);
                }

                // Mostra/esconde o bot√£o "Nova Partida" na tela de fim de jogo
                if (ui.gameMode.newGameBtn) {
                    ui.gameMode.newGameBtn.classList.toggle('hidden', !isAdmin);
                }

                // Adicione aqui qualquer outro controle de admin que precise ser mostrado/escondido no futuro.
            }

            // =======================================================================
            //  IN√çCIO: FUN√á√ïES DE HIST√ìRICO (L√ìGICA REFORMULADA)
            // =======================================================================

            async function fetchMatchHistory() {
                ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Buscando hist√≥rico...</p>`;
                try {
                    const q = query(matchesCollectionRef(), where("status", "==", "finished"), limit(50));
                    const querySnapshot = await getDocs(q);
                    let matches = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    matches.sort((a, b) => (b.endedAt?.seconds || 0) - (a.endedAt?.seconds || 0));
                    appState.matchHistory = matches;
                    renderMatchHistoryList();
                } catch (error) {
                    console.error("Erro ao buscar hist√≥rico:", error);
                    ui.history.matchList.innerHTML = `<p class="text-center text-red-500 p-8">N√£o foi poss√≠vel carregar o hist√≥rico.</p>`;
                }
            }

            function renderMatchHistoryList() {
                if (Object.keys(appState.players).length === 0) {
                    ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Carregando dados dos jogadores...</p>`;
                    return;
                }
                if (appState.matchHistory.length === 0) {
                    ui.history.matchList.innerHTML = `<p class="text-center text-gray-500 p-8">Nenhuma partida finalizada encontrada.</p>`;
                    return;
                }

                ui.history.matchList.innerHTML = appState.matchHistory.map(match => {
                const winnerId = match.winnerInfo?.winnerId;
                const winnerName = winnerId ? (appState.players[winnerId]?.name || 'Vencedor') : 'Empate';
                const date = match.endedAt?.seconds ? new Date(match.endedAt.seconds * 1000).toLocaleDateString('pt-BR') : 'Data indefinida';

                return `
                    <div onclick="showMatchDetails('${match.id}')" data-match-id="${match.id}" class="bg-white p-4 rounded-lg shadow-sm flex items-center justify-between cursor-pointer hover:bg-gray-50 transition-colors">
                        <div>
                            <p class="font-bold">${winnerName} venceu</p>
                            <p class="text-sm text-gray-500">Em ${date}</p>
                        </div>
                        <span class="text-gray-400">‚Ä∫</span>
                    </div>`;
            }).join('');
            }

            function showMatchDetails(matchId) {
                const matchData = appState.matchHistory.find(m => m.id === matchId);
                if (!matchData) return;

                // Executa a an√°lise para obter a lista real de participantes
                const { playerStats, raios } = analyzeMatchHistory(matchData);
                const listaParticipantes = Object.keys(playerStats);

                // --- LOG NO CONSOLE ---
                console.group(`üîç Detalhes da Partida: ${matchId}`);
                console.log("Todos os jogadores detectados no hist√≥rico (via scores):", listaParticipantes);
                console.table(listaParticipantes.map(id => ({
                    ID: id,
                    Nome: appState.players[id]?.name || "Jogador Antigo",
                    Pontos: playerStats[id].pontos,
                    Raios: playerStats[id].raios,
                    Lambretas:playerStats[id].lambretas
                })));
                console.groupEnd();

                appState.currentMatchDetails = matchData;
                ui.history.listView.classList.add('hidden');
                ui.history.detailsView.classList.remove('hidden');

                const winnerId = matchData.winnerInfo?.winnerId;
                const winnerName = winnerId ? (appState.players[winnerId]?.name || 'Vencedor') : 'Empate';
                ui.history.detailsHeader.innerHTML = `
                    <h2 class="text-2xl font-bold">${winnerName}</h2>
                    <p class="text-gray-500">${new Date(matchData.endedAt.seconds * 1000).toLocaleString('pt-BR', { dateStyle: 'long', timeStyle: 'short' })}</p>`;

                renderActiveHistoryTab();
            }

            function analyzeMatchHistory(matchData) {
                const playerStats = {};
                const totalStats = { lambretas: 0, conquistas: {} };
                const raios = [];
                let currentRaioRounds = [];
                let raioNumber = 1;

                // Fun√ß√£o auxiliar para garantir que o jogador existe no objeto antes de mexer nele
                const getStats = (id) => {
                    if (!id) return null;
                    if (!playerStats[id]) {
                        playerStats[id] = { pontos: 0, raios: 0, lambretas: 0, vitimaDeRoubo: 0, conquistas: {} };
                    }
                    return playerStats[id];
                };

                matchData.history.forEach((round) => {
                    const pId = round.winnerId;
                    const scoresObj = round.stateScore?.scores || round.scores || {};

                    // 1. SEMPRE garante que todos os IDs presentes no placar deste round existem nas stats
                    Object.keys(scoresObj).forEach(id => getStats(id));

                    if (round.type !== 'swap' && pId) {
                        const stats = getStats(pId);
                        if (stats) {
                            stats.pontos++;
                            currentRaioRounds.push(round);

                            if (round.completedRaio) {
                                stats.raios++;

                                // CAPTURA DE PARTICIPANTES: Pegamos todos os IDs que estavam no placar
                                // Isso garante que mesmo quem tem 0 pontos apare√ßa no gr√°fico
                                const participantes = new Set(Object.keys(scoresObj));
                                if (pId) participantes.add(pId);

                                raios.push({
                                    raioNumber: raioNumber++,
                                    winnerId: pId,
                                    completionTime: round.timestamp,
                                    pointSequence: currentRaioRounds.map((r, idx) => ({
                                        scorerId: r.winnerId,
                                        pointOrder: idx + 1
                                    })),
                                    participantesIds: Array.from(participantes)
                                });
                                currentRaioRounds = [];
                            }
                        }
                    }

                    // 2. Processa Lambretas (Manual/Hist√≥rico)
                    if (round.lambretaPlayerIds) {
                        round.lambretaPlayerIds.forEach(id => {
                            const s = getStats(id);
                            if (s) { s.lambretas++; totalStats.lambretas++; }
                        });
                    }

                    // 3. Processa Roubos
                    if (round.ladraoDeRaio?.vitma) {
                        round.ladraoDeRaio.vitma.forEach(id => {
                            const s = getStats(id);
                            if (s) s.vitimaDeRoubo++;
                        });
                    }
                });

                return { playerStats, totalStats, raios };
            }

            function renderMatchStats(matchData) {
                const { playerStats, totalStats, raios } = analyzeMatchHistory(matchData);

                const totalAchievementsHTML = Object.entries(totalStats.conquistas).map(([achId, count]) => {
                    const achInfo = achievements[achId];
                    if (!achInfo) return '';
                    return `<span class="inline-flex items-center gap-1 bg-yellow-100 text-yellow-800 text-xs font-medium px-2.5 py-0.5 rounded-full">${achInfo.icon} ${achInfo.name} ${count > 1 ? `(x${count})` : ''}</span>`;
                }).join(' ');

                const summaryBannerHTML = `
                    <div class="bg-blue-50 border border-blue-200 text-blue-800 p-4 rounded-lg mb-6 text-center">
                        <p class="font-semibold">Partida finalizada com <span class="font-bold">${raios.length}</span> ${raios.length === 1 ? 'raio' : 'raios'} e <span class="font-bold">${totalStats.lambretas}</span> ${totalStats.lambretas === 1 ? 'lambreta' : 'lambretas'}.</p>
                        ${totalAchievementsHTML ? `<div class="flex flex-wrap justify-center gap-2 mt-2">${totalAchievementsHTML}</div>` : ''}
                    </div>
                `;

                let contentHTML = summaryBannerHTML + '<div class="space-y-4">';
                // ITERAR SOBRE TODOS OS DETETADOS (Enzo, Rivelino, etc.)
                Object.keys(playerStats).forEach(id => {
                    const stats = playerStats[id];

                    // Opcional: n√£o mostrar jogadores que passaram pela mesa mas n√£o fizeram nada
                    // if (stats.pontos === 0 && stats.raios === 0 && stats.lambretas === 0) return;

                    const player = appState.players[id];
                    const displayName = player ? player.name : `Jogador Antigo (${id.substring(0,5)})`;

                    contentHTML += `
                        <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <p class="font-bold text-lg">${displayName}</p>
                            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 text-center">
                                <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">PONTOS</p><p class="font-bold text-lg">${stats.pontos}</p></div>
                                <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">RAIOS</p><p class="font-bold text-lg">${stats.raios}</p></div>
                                <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">LAMBRETAS</p><p class="font-bold text-lg">${stats.lambretas}</p></div>
                                <div class="bg-white p-2 rounded shadow-sm"><p class="text-xs font-semibold text-gray-500">MATCH POINT</p><p class="font-bold text-lg">${stats.vitimaDeRoubo}</p></div>
                            </div>
                        </div>`;
                });

                ui.history.detailsContent.innerHTML = contentHTML + '</div>';
            }

            function renderMatchRaios(matchData) {
                const { raios } = analyzeMatchHistory(matchData);
                if (raios.length === 0) {
                    ui.history.detailsContent.innerHTML = `<p class="text-center text-gray-500 p-8">Nenhum raio.</p>`;
                    return;
                }

                let contentHTML = '<div class="space-y-4">';
                raios.forEach((raio) => {
                    const winnerName = appState.players[raio.winnerId]?.name || 'Vencedor';
                    let playerTracksHTML = '';

                    // Iteramos sobre todos que passaram pela mesa NESTE RAIO
                    raio.participantesIds.forEach(playerId => {
                        const player = appState.players[playerId];
                        const playerName = player ? player.name : `Jogador (${playerId.substring(0,4)})`;

                        let circlesHTML = '';
                        // Filtramos os pontos que ESSE jogador espec√≠fico fez neste raio
                        const pointsInThisRaio = raio.pointSequence.filter(p => p.scorerId === playerId);

                        // Desenha sempre 4 espa√ßos
                        for (let i = 0; i < 4; i++) {
                            const pt = pointsInThisRaio[i];
                            if (pt) {
                                // Bolinha amarela com o n√∫mero da ordem do ponto na partida
                                circlesHTML += `<div class="point-circle rounded-full flex items-center justify-center bg-yellow-400 border-2 border-yellow-500 text-yellow-900 font-bold text-xs"><span>${pt.pointOrder}</span></div>`;
                            } else {
                                // Bolinha cinza (vazia)
                                circlesHTML += `<div class="point-circle rounded-full bg-gray-200 border-2 border-gray-300"></div>`;
                            }
                        }

                        playerTracksHTML += `
                            <div class="flex items-center gap-3">
                                <p class="font-semibold w-24 truncate text-right text-sm">${playerName}</p>
                                <div class="flex items-center gap-2">${circlesHTML}</div>
                            </div>`;
                    });

                    contentHTML += `
                        <div class="bg-gray-50 rounded-lg border border-gray-200 p-4">
                            <p class="font-bold text-center mb-3 text-blue-900">Raio de ${winnerName}</p>
                            <div class="space-y-2">${playerTracksHTML}</div>
                        </div>`;
                });
                ui.history.detailsContent.innerHTML = contentHTML + '</div>';
            }

            function setActiveHistoryTab(tabName) {
                ui.history.tabs.forEach(tab => tab.classList.remove('active'));
                const activeTab = document.querySelector(`.history-details-tab[data-tab="${tabName}"]`);
                if (activeTab) activeTab.classList.add('active');
            }

            function renderActiveHistoryTab() {
                if (!appState.currentMatchDetails) return;
                const activeTabName = document.querySelector('.history-details-tab.active')?.dataset.tab || 'stats';
                if (activeTabName === 'stats') {
                    renderMatchStats(appState.currentMatchDetails);
                } else {
                    renderMatchRaios(appState.currentMatchDetails);
                }
            }

            function showScoreboardFromHistory() {
                if (!ui.history.detailsView.classList.contains('hidden')) {
                    ui.history.detailsView.classList.add('hidden');
                    ui.history.listView.classList.remove('hidden');
                    appState.currentMatchDetails = null;
                } else {
                    switchView('view-scoreboard');
                }
            }

            // =======================================================================
            //  FIM: FUN√á√ïES DE HIST√ìRICO
            // =======================================================================

            // Ativa√ß√£o do modo admin
            function toggleAdminPanel(e) {
                // Verifica se o clique foi no bot√£o FAB (n√£o no painel)
                if (e.target.closest('#adminFabButton')) {
                    ui.adminFab.button.classList.toggle('active');
                    ui.adminFab.defaultIcon.classList.toggle('hidden');
                    ui.adminFab.closeIcon.classList.toggle('hidden');
                    ui.adminFab.panel.classList.toggle('active');

                    if (!ui.adminFab.panel.classList.contains('active') && !appState.isAdminMode) {
                        ui.adminFab.loginView.style.display = 'block';
                        ui.adminFab.controlsView.style.display = 'none';
                        ui.adminFab.keyInput.value = '';
                    }
                }
            }
            // Adicionar este listener para fechar quando clicar fora
            document.addEventListener('click', (e) => {
                const isClickInsidePanel = ui.adminFab.panel.contains(e.target);
                const isClickOnFabButton = e.target.closest('#adminFabButton');

                if (ui.adminFab.panel.classList.contains('active') && !isClickInsidePanel && !isClickOnFabButton) {
                    ui.adminFab.button.classList.remove('active');
                    ui.adminFab.defaultIcon.classList.remove('hidden');
                    ui.adminFab.closeIcon.classList.add('hidden');
                    ui.adminFab.panel.classList.remove('active');

                    if (!appState.isAdminMode) {
                        ui.adminFab.loginView.style.display = 'block';
                        ui.adminFab.controlsView.style.display = 'none';
                        ui.adminFab.keyInput.value = '';
                    }
                }
            });



            function activateAdminMode() { if(ui.adminFab.keyInput.value === ADMIN_KEY) { appState.isAdminMode = true; ui.adminFab.loginView.style.display = 'none'; ui.adminFab.controlsView.style.display = 'block'; updateAdminUI(); } else { alert('Senha incorreta!'); }}

            // function switchView(viewId) { ui.views.forEach(v => v.classList.toggle('active', v.id === viewId)); }

            // EVENT LISTENERS

            // Listners Do historicoDeRaios
            document.addEventListener('DOMContentLoaded', () => {
                ui.history.fabButton.addEventListener('click', () => {
                    switchView('view-history');
                    fetchMatchHistory();
                });

                ui.history.backButton.addEventListener('click', showScoreboardFromHistory);

                ui.history.matchList.addEventListener('click', (e) => {
                    const matchCard = e.target.closest('[data-match-id]');
                    if (matchCard) {
                        showMatchDetails(matchCard.dataset.matchId);
                    }
                });

                ui.history.tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        setActiveHistoryTab(tab.dataset.tab);
                        renderActiveHistoryTab();
                    });
                });
            });
            // ----------------------------

            ui.adminFab.addPlayerBtn.addEventListener('click', addNovoJogador);

            // Listener para o modo partida que estava comentado
            ui.gameMode.startBtn.addEventListener('click', createGameInFirestore);

            // Adicione estes novos listeners:
            ui.gameMode.launchScoreBtn.addEventListener('click', launchScore);
            ui.gameMode.undoBtn.addEventListener('click', undoRound);
            ui.gameMode.swapPlayerBtn.addEventListener('click', iniciarTrocaDeJogador);
            ui.gameMode.endBtn.addEventListener('click', () => endGame(false)); // a confirma√ß√£o √© interna
            ui.gameMode.backToScoreboard_GameOverBtn.addEventListener('click', () => {
                switchView('view-scoreboard');
            });

            // Listener para expandir/recolher o feed da partida ao vivo
            ui.liveMatchHeader.addEventListener('click', () => {
                // S√ì EXECUTA A A√á√ÉO SE HOUVER UM JOGO ATIVO NO ESTADO
                if (!appState.gameState.activeGame) {
                    return;
                }
                ui.liveMatchFeed.classList.toggle('open');
                ui.liveMatchChevron.classList.toggle('open');
            });

            ui.gameMode.newGameBtn.addEventListener('click', () => { resetGameState(); switchView('view-game-table'); });
            ui.gameMode.gameOver.gameSummaryBtn.addEventListener('click', () => showGameSummary());

            // ui.adminFab.button.addEventListener('click', toggleAdminPanel);
            ui.adminFab.button.addEventListener('click', (e) => toggleAdminPanel(e));
            ui.adminFab.activateBtn.addEventListener('click', activateAdminMode);
            ui.adminFab.keyInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    activateAdminMode();
                }
            });

            ui.adminFab.addPlayerBtn.addEventListener('click', addNovoJogador);
            ui.notificationsBtn.addEventListener('click',async () => {
                if ('serviceWorker' in navigator && 'Notification' in window) {
                try {
                    const registration = await navigator.serviceWorker.register('/placar_domino/service-worker.js', {
                    scope: '/placar_domino/'
                    });
                    // console.log('SW registrado:', registration.scope);
                    requestPermissionAndGetToken(registration);
                } catch (error) {
                    console.error('Erro ao registrar Service Worker:', error);
                }
                } else {
                console.warn("SW ou Notification API n√£o suportado");
                }
            });

            ui.gameMode.goToBtn.addEventListener('click', handleStartGameClick);
            ui.gameMode.backBtn.addEventListener('click', () => endGame(false));
            ui.gameMode.modeButtons.forEach(btn => btn.addEventListener('click', () => { if (!appState.gameState.activeGame) { appState.gameState.gameMode = btn.dataset.mode; updateGameModeUI(); }}));
            // ui.gameMode.raioCheckbox.addEventListener('change', (e) => { if (!appState.gameState.activeGame) appState.gameState.isRaioMatch = e.target.checked; });
            ui.gameMode.raioCheckbox.addEventListener('change', (e) => {
                if (!appState.gameState.activeGame) {
                    appState.gameState.isRaioMatch = e.target.checked;
                    // Se o modo raio for ATIVADO, mostra a mensagem.
                    if (e.target.checked) {
                        showMessage("Modo Raio Ativado: Lambretas ser√£o registradas manualmente a cada raio.", 'info');
                    }
                }
            });
             // ui.gameMode.startBtn.addEventListener('click', startGame); // startGame precisa ser definida

            ui.playersListDiv.addEventListener('click', e => {
                const target = e.target.closest('.player-name-clickable');
                if (target) openPlayerDetailsModal(target.dataset.playerId);
            });

            // SUBSTITUA O LISTENER ANTIGO DO MODAL POR ESTE
            ui.modal.container.addEventListener('click', (e) => {
                const target = e.target;

                // 1. L√≥gica para fechar o modal (executada primeiro)
                if (target.id === 'modalContainer' || target.closest('#modal-close-btn') || target.closest('#modal-cancel-btn')) {
                    closeModal();
                    return; // Para a execu√ß√£o aqui
                }

                // 2. L√≥gica de Sele√ß√£o de Jogador (para a mesa)
                // Esta verifica√ß√£o agora acontece ANTES das de admin.
                const playerSelectBtn = target.closest('.player-select-btn');
                if (playerSelectBtn && !appState.gameState.activeGame) {
                    selectPlayer(playerSelectBtn.dataset.playerId);
                    return; // Para a execu√ß√£o aqui ap√≥s selecionar
                }

                // 3. L√≥gica do Admin (s√≥ √© checada se as anteriores falharem)
                if (appState.isAdminMode) {
                    // Pega o ID do jogador que est√° sendo visualizado no modal de detalhes
                    const playerId = appState.modalContext?.currentViewedPlayerId;

                    // A√ß√µes que dependem de um jogador espec√≠fico no modal
                    const statButton = target.closest('.stat-button');
                    const renameButton = target.closest('#btnRenamePlayer');
                    const deleteButton = target.closest('#btnDeletePlayer');

                    if (statButton && playerId) {
                        const { action, stat } = statButton.dataset;
                        const amount = action === 'increment' ? 1 : -1;
                        const valueElement = document.getElementById(`${stat}-value`);
                        const currentValue = parseInt(valueElement.textContent, 10);
                        const newValue = currentValue + amount;

                        if (newValue >= 0) {
                            valueElement.textContent = newValue;
                            updatePlayerStat(playerId, stat, amount);
                        } else {
                            showMessage(`N√£o √© poss√≠vel ter valor negativo.`, 'error');
                        }
                        return;
                    }

                    if (renameButton && playerId) {
                        renomearJogador(playerId);
                        return;
                    }

                    if (deleteButton && playerId) {
                        deletarJogador(playerId);
                        return;
                    }
                }
            });

            // For√ßar atualiza√ß√£o do Service Worker
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', async () => {
                    try {
                        const swPath = './service-worker.js'; // ou ajuste para seu caso
                        const registration = await navigator.serviceWorker.register(swPath);

                        // Verifica por atualiza√ß√£o imediatamente
                        registration.update();

                        registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        if (!newWorker) return;

                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                newWorker.postMessage('SKIP_WAITING');
                                window.location.reload(); // for√ßa reload autom√°tico
                            }
                        });
                    });

                    } catch (err) {
                        console.error('Erro ao registrar Service Worker:', err);
                    }
                });

                // Verifica atualiza√ß√µes a cada 1h
                setInterval(() => {
                    navigator.serviceWorker.getRegistration().then(reg => reg?.update());
                }, 60 * 60 * 1000);
            }

        </script>
    </body>
    </html>
